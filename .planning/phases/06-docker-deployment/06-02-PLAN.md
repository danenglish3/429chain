---
phase: 06-docker-deployment
plan: 02
type: execute
wave: 2
depends_on: ["06-01"]
files_modified:
  - docker-compose.yml
  - .env.example
  - .gitignore
autonomous: true

must_haves:
  truths:
    - "User can run docker compose up and have proxy running on port 3429"
    - "Configuration persists through bind mount of config.yaml"
    - "SQLite database persists through named volume on /app/data"
    - "Health check reports container status using /health endpoint"
    - "Environment variables can override config settings"
  artifacts:
    - path: "docker-compose.yml"
      provides: "Service orchestration with volumes, health check, and restart policy"
      contains: "services:"
    - path: ".env.example"
      provides: "Template for environment variables with documentation"
      contains: "NODE_ENV"
  key_links:
    - from: "docker-compose.yml"
      to: "Dockerfile"
      via: "build context reference"
      pattern: "build:"
    - from: "docker-compose.yml"
      to: "/health"
      via: "healthcheck test command"
      pattern: "curl.*health"
    - from: "docker-compose.yml"
      to: "config/config.yaml"
      via: "bind mount for user config"
      pattern: "config.yaml.*:ro"
    - from: "docker-compose.yml"
      to: "/app/data"
      via: "named volume for SQLite persistence"
      pattern: "data:/app/data"
---

<objective>
Create docker-compose.yml for single-command deployment with volume mounts, environment variable handling, and health check integration.

Purpose: docker-compose.yml is what users actually interact with. It orchestrates the container with correct volume mounts (named volume for SQLite data, bind mount for config), environment variables, health checks, and restart policy. Combined with .env.example, it gives users everything they need for `docker compose up`.

Output: docker-compose.yml, .env.example, updated .gitignore.
</objective>

<execution_context>
@C:\Users\danen\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\danen\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/06-docker-deployment/06-RESEARCH.md

@package.json
@src/index.ts
@src/config/loader.ts
@config/config.example.yaml
@.gitignore
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create docker-compose.yml with volumes, health check, and environment handling</name>
  <files>docker-compose.yml</files>
  <action>
Create `docker-compose.yml` at project root. This is the primary deployment interface.

```yaml
services:
  proxy:
    build:
      context: .
      dockerfile: Dockerfile
    image: 429chain:latest
    container_name: 429chain-proxy
    init: true
    ports:
      - "${PORT:-3429}:3429"
    volumes:
      - data:/app/data
      - ./config/config.yaml:/app/config/config.yaml:ro
    environment:
      - NODE_ENV=production
      - CONFIG_PATH=/app/config/config.yaml
    env_file:
      - path: ./.env
        required: false
    healthcheck:
      test: ["CMD", "curl", "-f", "http://localhost:3429/health"]
      interval: 30s
      timeout: 3s
      retries: 3
      start_period: 10s
    restart: unless-stopped

volumes:
  data:
    driver: local
```

Key details:
- `init: true` enables tini for proper PID 1 signal handling (graceful shutdown)
- `data:/app/data` is a named volume -- Docker manages it, survives `docker compose down`, persists SQLite .db + .db-wal + .db-shm files together (important for WAL mode -- mount directory, not individual file)
- `./config/config.yaml:/app/config/config.yaml:ro` bind mounts user config as read-only (admin API writes to this file, but that happens inside the container's copy -- wait, the admin API uses `configPath` which would be `/app/config/config.yaml` which is the bind mount. The `:ro` flag would prevent writes. Remove `:ro` so the admin API can persist config changes back to the host)
- CORRECTION: Remove `:ro` from config bind mount. The admin API (PUT /v1/admin/providers, etc.) writes config changes back to the YAML file via `configPath`. If mounted read-only, admin config changes won't persist across container restarts.
- `env_file` with `required: false` allows running without .env file
- `${PORT:-3429}` in host port allows override but container always listens on 3429
- Health check uses existing `/health` endpoint with reasonable intervals
- `restart: unless-stopped` auto-restarts on crash but not after explicit stop

Do NOT include `version: '3.8'` -- it's deprecated in modern Docker Compose v2 and triggers warnings. The top-level `services:` key is sufficient.

Do NOT include `deploy.resources` limits -- these are only for Docker Swarm mode and ignored by `docker compose up`. They'd add confusion without benefit for single-host deployment.

Add comments in the YAML explaining each volume mount and the health check configuration.
  </action>
  <verify>Verify file exists and has correct structure: `test -f docker-compose.yml && grep -q "services:" docker-compose.yml && grep -q "data:/app/data" docker-compose.yml && grep -q "healthcheck:" docker-compose.yml && grep -q "init: true" docker-compose.yml`</verify>
  <done>docker-compose.yml exists with named volume for data persistence, bind mount for config (writable for admin API), health check using /health, init for signal handling, and restart policy</done>
</task>

<task type="auto">
  <name>Task 2: Create .env.example and update .gitignore</name>
  <files>.env.example, .gitignore</files>
  <action>
**Create `.env.example`** at project root with documented environment variables:

```bash
# 429chain Docker Environment Variables
# Copy to .env and customize for your deployment

# Node environment (production recommended for Docker)
NODE_ENV=production

# Host port mapping (container always listens on 3429 internally)
# PORT=3429

# Config file path inside container (matches volume mount)
# CONFIG_PATH=/app/config/config.yaml

# Database path inside container (must be in mounted volume)
# DB_PATH=/app/data/observability.db

# Log level (trace, debug, info, warn, error, fatal)
# LOG_LEVEL=info
```

Commented-out variables show defaults. Only NODE_ENV is uncommented as the primary setting users would keep.

Note: DB_PATH and LOG_LEVEL are shown for documentation but these are controlled by config.yaml settings.dbPath and settings.logLevel respectively. They are NOT read from environment variables by the application -- include a comment explaining this: "These settings are configured in config.yaml, not via environment variables. Shown here for reference only."

Actually, reviewing `src/config/loader.ts`, the app reads config from the YAML file, not environment variables (except CONFIG_PATH). So .env.example should only document CONFIG_PATH and NODE_ENV as actually functional env vars, plus PORT for the docker-compose host port mapping. Other settings are in config.yaml.

Revised .env.example:

```bash
# 429chain Docker Environment Variables
# Copy to .env and customize for your deployment
#
# Note: Most settings are configured in config/config.yaml
# Only the variables below are read from the environment.

# Node environment
NODE_ENV=production

# Host port for Docker port mapping (default: 3429)
# The container always listens on port 3429 internally
# PORT=3429

# Config file path inside container (default: /app/config/config.yaml)
# Only change if you mount config to a different path
# CONFIG_PATH=/app/config/config.yaml
```

**Update `.gitignore`** to add:
- `data/` directory (SQLite database files, created at runtime)
- `*.db`, `*.db-wal`, `*.db-shm` (SQLite database files)

Read the existing .gitignore first, then append the new entries under a `# Docker / Data` section comment. Do NOT duplicate existing entries.
  </action>
  <verify>Verify files exist and have correct content: `test -f .env.example && grep -q "NODE_ENV" .env.example && grep -q "data/" .gitignore && grep -q "*.db" .gitignore`</verify>
  <done>.env.example exists with documented environment variables (only functional ones: NODE_ENV, PORT, CONFIG_PATH). .gitignore updated with data/ directory and SQLite file patterns.</done>
</task>

</tasks>

<verification>
- `docker-compose.yml` exists with services.proxy defined
- Named volume `data` maps to `/app/data` for SQLite persistence
- Config bind mount is writable (no `:ro`) for admin API config writes
- Health check uses `curl -f http://localhost:3429/health`
- `init: true` present for signal handling
- `.env.example` documents functional env vars only
- `.gitignore` includes data/ and *.db patterns
</verification>

<success_criteria>
- `docker compose config` would validate the compose file (syntax correct)
- Volume mount strategy preserves both config changes and database across restarts
- Health check configuration matches existing /health endpoint
- .env.example is clear and not misleading about what env vars actually do
</success_criteria>

<output>
After completion, create `.planning/phases/06-docker-deployment/06-02-SUMMARY.md`
</output>
