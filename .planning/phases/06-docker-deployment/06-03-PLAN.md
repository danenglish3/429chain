---
phase: 06-docker-deployment
plan: 03
type: execute
wave: 3
depends_on: ["06-02"]
files_modified: []
autonomous: false

must_haves:
  truths:
    - "docker compose up builds and starts the container successfully"
    - "Proxy responds on port 3429 with health check passing"
    - "Web UI is accessible in browser at http://localhost:3429"
    - "SQLite data persists after docker compose down and docker compose up"
    - "Container stops gracefully on docker compose down (no 10s timeout kill)"
  artifacts: []
  key_links:
    - from: "docker-compose.yml"
      to: "Dockerfile"
      via: "build context"
      pattern: "build:"
    - from: "Dockerfile"
      to: "/health"
      via: "HEALTHCHECK directive"
      pattern: "curl.*health"
    - from: "docker-compose.yml"
      to: "data volume"
      via: "named volume mount"
      pattern: "data:/app/data"
---

<objective>
Validate the complete Docker deployment end-to-end: build, run, health check, persistence, and graceful shutdown.

Purpose: The Dockerfile and docker-compose.yml are only useful if they actually work together. This plan runs automated validation checks and then asks the user to verify the full deployment experience.

Output: Validated, working Docker deployment. No new files created.
</objective>

<execution_context>
@C:\Users\danen\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\danen\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/06-docker-deployment/06-RESEARCH.md

@Dockerfile
@docker-compose.yml
@.dockerignore
@.env.example
@config/config.example.yaml
</context>

<tasks>

<task type="auto">
  <name>Task 1: Automated Docker build and validation</name>
  <files></files>
  <action>
Run automated validation checks. If Docker is not available on the system, skip gracefully and note it for the checkpoint.

1. **Verify Docker is available:**
   ```bash
   docker --version
   docker compose version
   ```
   If either fails, log that Docker is not installed and skip to the checkpoint task. This is expected on some development machines.

2. **Verify config file exists for bind mount:**
   Check that `config/config.yaml` exists (required by docker-compose bind mount). If only `config/config.example.yaml` exists, copy it to `config/config.yaml` so the bind mount works. The .gitignore already excludes config/config.yaml.

3. **Build the Docker image:**
   ```bash
   docker compose build
   ```
   This should complete without errors. Verify all 4 stages execute.

4. **Start the container:**
   ```bash
   docker compose up -d
   ```
   Wait a few seconds for startup.

5. **Check container health:**
   ```bash
   docker compose ps
   ```
   Should show container as "healthy" (may need to wait for start_period + one interval = ~40s).

6. **Test health endpoint:**
   ```bash
   curl -f http://localhost:3429/health
   ```
   Should return JSON with `{"status":"ok",...}`.

7. **Test graceful shutdown:**
   ```bash
   docker compose down
   ```
   Should complete in under 3 seconds (not the 10s forced kill timeout).

If any step fails, document the error clearly for debugging. Common failures:
- Port 3429 already in use (stop local dev server first)
- config/config.yaml missing (copy from example)
- better-sqlite3 build failure (should not happen with node:20-slim, but if it does, check Dockerfile deps stage)
  </action>
  <verify>Container builds without errors; `curl http://localhost:3429/health` returns status ok; `docker compose down` completes within 5 seconds</verify>
  <done>Docker image builds successfully, container starts and passes health check, graceful shutdown works</done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <what-built>Complete Docker deployment: multi-stage Dockerfile, docker-compose.yml with volumes and health checks, .env.example, .dockerignore</what-built>
  <how-to-verify>
1. If the automated checks above succeeded, verify the container is running:
   - Open browser to http://localhost:3429 -- should see the 429chain Web UI
   - Check http://localhost:3429/health -- should return JSON health status

2. Test persistence across restarts:
   - With container running, make a configuration change via the Web UI (e.g., add a test provider)
   - Run `docker compose down` then `docker compose up -d`
   - Verify the configuration change persisted
   - Verify the Web UI still loads

3. Check container health status:
   - Run `docker compose ps` -- Status column should show "healthy"

4. If Docker was not available for automated checks:
   - Install Docker Desktop or Docker Engine
   - Run `docker compose up --build -d` to build and start
   - Follow steps 1-3 above

Expected outcomes:
- Web UI loads at http://localhost:3429
- Health endpoint returns `{"status":"ok",...}`
- Config changes survive container restart (via bind mount)
- Container shows "healthy" in docker compose ps
  </how-to-verify>
  <resume-signal>Type "approved" if deployment works, or describe any issues encountered</resume-signal>
</task>

</tasks>

<verification>
- Docker image builds from Dockerfile without errors
- Container starts and health check passes
- Port 3429 accessible with proxy and Web UI
- Data persists across container restart
- Graceful shutdown (under 5 seconds, not forced kill)
</verification>

<success_criteria>
- `docker compose up` brings up a fully functional 429chain instance
- Health endpoint responds with status ok
- Web UI accessible in browser
- SQLite data and config persist through restart cycles
- Container shuts down gracefully
</success_criteria>

<output>
After completion, create `.planning/phases/06-docker-deployment/06-03-SUMMARY.md`
</output>
