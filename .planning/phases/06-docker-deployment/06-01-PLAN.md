---
phase: 06-docker-deployment
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - Dockerfile
  - .dockerignore
autonomous: true

must_haves:
  truths:
    - "Docker image builds successfully with multi-stage Dockerfile"
    - "Final image contains only production dependencies and built artifacts"
    - "Image runs as non-root node user"
  artifacts:
    - path: "Dockerfile"
      provides: "Multi-stage build definition with deps, builder, ui-builder, and production stages"
      contains: "FROM node:20-slim"
    - path: ".dockerignore"
      provides: "Build context exclusions for fast builds"
      contains: "node_modules"
  key_links:
    - from: "Dockerfile"
      to: "package.json"
      via: "COPY package*.json for dependency install"
      pattern: "COPY package.*json"
    - from: "Dockerfile"
      to: "ui/package.json"
      via: "COPY ui/package*.json for UI dependency install"
      pattern: "COPY ui/package.*json"
---

<objective>
Create the multi-stage Dockerfile and .dockerignore for building a production-ready 429chain container image.

Purpose: The Dockerfile is the foundation of Docker deployment. It must build both the backend (TypeScript via tsdown) and frontend (Vite React SPA), install only production dependencies including the native better-sqlite3 module, and produce a minimal image that runs securely as non-root.

Output: Dockerfile with 4 build stages, .dockerignore for optimized build context.
</objective>

<execution_context>
@C:\Users\danen\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\danen\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/06-docker-deployment/06-RESEARCH.md

@package.json
@ui/package.json
@tsconfig.json
@src/index.ts
@.gitignore
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create .dockerignore for build context optimization</name>
  <files>.dockerignore</files>
  <action>
Create `.dockerignore` at project root to exclude files from Docker build context. This speeds up builds and reduces image size.

Exclude:
- `node_modules` and `ui/node_modules` (dependencies installed inside container)
- `dist` and `ui/dist` (build outputs created inside container)
- `.git`, `.github`, `.gitignore`, `.gitattributes`
- `.vscode`, `.idea`, `.DS_Store`, `Thumbs.db`
- `*.log`, `npm-debug.log*`
- `.env`, `.env.*` BUT keep `!.env.example`
- `coverage`, `.nyc_output`
- `**/*.test.ts`, `**/*.spec.ts`, `**/__tests__`, `**/__mocks__`
- `*.md` BUT keep `!README.md`
- `.planning` directory
- `*.db`, `*.sqlite`, `*.db-wal`, `*.db-shm` (database files mounted as volumes)
- `data/` directory
- `*.tsbuildinfo`
- `nul` (Windows artifact in repo)

Add comments explaining each section for maintainability.
  </action>
  <verify>Verify file exists and contains expected entries: `test -f .dockerignore && grep -q "node_modules" .dockerignore && grep -q ".planning" .dockerignore`</verify>
  <done>.dockerignore exists with all exclusion categories listed above, properly commented</done>
</task>

<task type="auto">
  <name>Task 2: Create multi-stage Dockerfile</name>
  <files>Dockerfile</files>
  <action>
Create `Dockerfile` at project root with 4 stages. Use `node:20-slim` base (NOT Alpine -- better-sqlite3 native module has musl libc compatibility issues with Alpine).

**Stage 1: deps** - Production dependencies only
```
FROM node:20-slim AS deps
WORKDIR /app
COPY package.json package-lock.json ./
RUN npm ci --omit=dev && npm cache clean --force
```
Note: Use `--omit=dev` (modern npm syntax, replaces deprecated `--only=production`).

**Stage 2: builder** - Build backend TypeScript
```
FROM node:20-slim AS builder
WORKDIR /app
COPY package.json package-lock.json ./
RUN npm ci
COPY tsconfig.json ./
COPY src ./src
RUN npm run build
```
This runs `tsdown src/index.ts --format esm --dts` which outputs to `dist/`.

**Stage 3: ui-builder** - Build Vite React SPA
```
FROM node:20-slim AS ui-builder
WORKDIR /app/ui
COPY ui/package.json ui/package-lock.json ./
RUN npm ci
COPY ui/ ./
RUN npm run build
```
This runs `tsc -b && vite build` which outputs to `ui/dist/`.

**Stage 4: production** - Minimal runtime
```
FROM node:20-slim
WORKDIR /app
```
In this stage:
1. Install curl for health checks: `RUN apt-get update && apt-get install -y --no-install-recommends curl && rm -rf /var/lib/apt/lists/*`
2. Create data directory with correct ownership: `RUN mkdir -p /app/data && chown -R node:node /app`
3. Switch to non-root user: `USER node`
4. Copy production node_modules from deps: `COPY --from=deps --chown=node:node /app/node_modules ./node_modules`
5. Copy built backend from builder: `COPY --from=builder --chown=node:node /app/dist ./dist`
6. Copy built UI from ui-builder: `COPY --from=ui-builder --chown=node:node /app/ui/dist ./ui/dist`
7. Copy package.json for metadata: `COPY --chown=node:node package.json ./`
8. Expose port: `EXPOSE 3429`
9. Set environment: `ENV NODE_ENV=production`
10. Add health check: `HEALTHCHECK --interval=30s --timeout=3s --start-period=10s --retries=3 CMD curl -f http://localhost:3429/health || exit 1`
11. Start command: `CMD ["node", "dist/index.js"]`

Do NOT use `npm start` as CMD -- npm absorbs signals and prevents graceful shutdown. Use `node dist/index.js` directly. The `init: true` in docker-compose handles PID 1 signal forwarding via tini.

Add comments at the top of the Dockerfile explaining the multi-stage approach.
  </action>
  <verify>Verify Dockerfile syntax is valid: `test -f Dockerfile && grep -q "FROM node:20-slim AS deps" Dockerfile && grep -q "FROM node:20-slim AS builder" Dockerfile && grep -q "FROM node:20-slim AS ui-builder" Dockerfile && grep -q "HEALTHCHECK" Dockerfile && grep -q 'CMD \["node"' Dockerfile`</verify>
  <done>Dockerfile exists with 4 stages (deps, builder, ui-builder, production), uses node:20-slim base, runs as non-root node user, has HEALTHCHECK directive, and uses node directly as CMD</done>
</task>

</tasks>

<verification>
- `.dockerignore` exists and excludes node_modules, dist, .git, .planning, database files
- `Dockerfile` has 4 FROM statements (one per stage)
- Final stage uses `USER node` for non-root execution
- HEALTHCHECK points to `http://localhost:3429/health`
- CMD uses `node dist/index.js` not `npm start`
- No Alpine images used (only node:20-slim)
</verification>

<success_criteria>
- Both files exist at project root
- Dockerfile follows multi-stage best practices from research
- .dockerignore excludes all build context noise
- No security anti-patterns (no root user, no npm as entrypoint)
</success_criteria>

<output>
After completion, create `.planning/phases/06-docker-deployment/06-01-SUMMARY.md`
</output>
