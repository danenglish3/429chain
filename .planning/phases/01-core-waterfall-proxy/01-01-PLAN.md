---
phase: 01-core-waterfall-proxy
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - package.json
  - tsconfig.json
  - vitest.config.ts
  - config/config.example.yaml
  - src/config/schema.ts
  - src/config/loader.ts
  - src/config/types.ts
  - src/shared/errors.ts
  - src/shared/logger.ts
  - src/shared/types.ts
autonomous: true

must_haves:
  truths:
    - "npm install succeeds and all dependencies resolve"
    - "TypeScript compilation passes with zero errors"
    - "Loading a valid YAML config returns a fully typed Config object"
    - "Loading an invalid YAML config prints a human-readable Zod error and exits non-zero"
    - "Logger output is structured JSON and never contains API key values"
  artifacts:
    - path: "package.json"
      provides: "Project manifest with all Phase 1 dependencies"
      contains: "hono"
    - path: "tsconfig.json"
      provides: "TypeScript configuration for Node 20+ ESM project"
      contains: "NodeNext"
    - path: "src/config/schema.ts"
      provides: "Zod schemas for config file validation"
      exports: ["ConfigSchema", "ProviderSchema", "ChainSchema"]
    - path: "src/config/loader.ts"
      provides: "YAML loading and Zod validation"
      exports: ["loadConfig"]
    - path: "src/config/types.ts"
      provides: "TypeScript types inferred from Zod schemas"
      exports: ["Config", "ProviderConfig", "ChainConfig", "ChainEntryConfig"]
    - path: "src/shared/errors.ts"
      provides: "Custom error classes for proxy"
      exports: ["ProviderError", "ProviderRateLimitError", "AllProvidersExhaustedError", "ConfigError"]
    - path: "src/shared/logger.ts"
      provides: "Pino logger with API key redaction"
      exports: ["logger"]
    - path: "src/shared/types.ts"
      provides: "OpenAI request/response type definitions"
      exports: ["ChatCompletionRequest", "ChatCompletionResponse", "OpenAIErrorResponse"]
    - path: "config/config.example.yaml"
      provides: "Example config with all fields documented"
      contains: "version: 1"
  key_links:
    - from: "src/config/types.ts"
      to: "src/config/schema.ts"
      via: "z.infer<typeof ConfigSchema>"
      pattern: "z\\.infer"
    - from: "src/config/loader.ts"
      to: "src/config/schema.ts"
      via: "ConfigSchema.safeParse()"
      pattern: "ConfigSchema\\.safeParse"
    - from: "src/shared/logger.ts"
      to: "pino"
      via: "redact config for authorization headers"
      pattern: "redact"
---

<objective>
Set up the 429chain project from scratch: Node.js TypeScript project with all Phase 1 dependencies, Zod-validated YAML config loading, structured logging with secret redaction, custom error classes, and OpenAI-compatible type definitions.

Purpose: Every subsequent plan depends on these foundations -- config types, error classes, logger, and shared types. This plan creates the soil everything grows from.
Output: A buildable TypeScript project with validated config loading, structured logging, and all shared types.
</objective>

<execution_context>
@C:\Users\danen\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\danen\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-core-waterfall-proxy/01-RESEARCH.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Project scaffolding and dependency installation</name>
  <files>package.json, tsconfig.json, vitest.config.ts, .gitignore</files>
  <action>
Initialize the Node.js project and install all dependencies for Phase 1.

1. Run `npm init -y` in the project root (C:\Users\danen\Documents\429chain).
2. Update package.json:
   - Set `"name": "429chain"`, `"type": "module"`, `"version": "0.1.0"`
   - Set `"engines": { "node": ">=20.0.0" }`
   - Add scripts:
     - `"dev": "tsx watch src/index.ts"`
     - `"build": "tsdown src/index.ts --format esm --dts"`
     - `"start": "node dist/index.js"`
     - `"test": "vitest run"`
     - `"test:watch": "vitest"`
     - `"typecheck": "tsc --noEmit"`
3. Install production dependencies:
   `npm install hono @hono/node-server zod yaml pino nanoid ms`
4. Install dev dependencies:
   `npm install -D typescript tsx tsdown vitest @types/node @types/ms`
5. Create tsconfig.json:
   - `"target": "ES2022"`, `"module": "NodeNext"`, `"moduleResolution": "NodeNext"`
   - `"outDir": "dist"`, `"rootDir": "src"`
   - `"strict": true`, `"skipLibCheck": true`, `"esModuleInterop": true`
   - `"resolveJsonModule": true`, `"declaration": true`
   - `"include": ["src"]`, `"exclude": ["node_modules", "dist"]`
6. Create vitest.config.ts:
   ```typescript
   import { defineConfig } from 'vitest/config';
   export default defineConfig({
     test: {
       globals: true,
       environment: 'node',
     },
   });
   ```
7. Create or update .gitignore with: node_modules, dist, *.log, .env, config/config.yaml (but NOT config/config.example.yaml).

IMPORTANT: Use `"type": "module"` in package.json. All source files use ESM imports (import/export, not require). File extensions in imports are NOT needed with NodeNext module resolution when importing .ts files within the project -- TypeScript handles this. However, for the built output, tsdown will handle bundling.
  </action>
  <verify>
Run `npm install` (should succeed with exit code 0), then `npx tsc --noEmit` (should succeed -- no source files yet, but config is valid). Verify package.json has all expected dependencies.
  </verify>
  <done>
Project has package.json with all Phase 1 deps, tsconfig.json for ESM Node 20+, vitest.config.ts, and .gitignore. `npm install` succeeds.
  </done>
</task>

<task type="auto">
  <name>Task 2: Config schema, loader, shared types, errors, and logger</name>
  <files>
    src/config/schema.ts
    src/config/loader.ts
    src/config/types.ts
    src/shared/errors.ts
    src/shared/logger.ts
    src/shared/types.ts
    config/config.example.yaml
  </files>
  <action>
Create the foundational source files that all subsequent plans depend on.

**src/config/schema.ts** -- Zod schemas for YAML config validation:
- `ProviderSchema`: object with `id` (string), `name` (string), `type` (enum: 'openrouter', 'groq', 'cerebras', 'generic-openai'), `apiKey` (string, min 1), `baseUrl` (string url, optional -- each provider type has a known default)
- `ChainEntrySchema`: object with `provider` (string, references a provider.id), `model` (string)
- `ChainSchema`: object with `name` (string), `entries` (array of ChainEntrySchema, min 1)
- `SettingsSchema`: object with `port` (number, 1-65535, default 3429), `apiKeys` (array of string min 1, min 1 entry), `defaultChain` (string), `logLevel` (enum: debug/info/warn/error, default 'info'), `cooldownDefaultMs` (number, min 1000, default 60000), `requestTimeoutMs` (number, min 1000, default 30000)
- `ConfigSchema`: object with `version` (literal 1), `settings` (SettingsSchema), `providers` (array ProviderSchema, min 1), `chains` (array ChainSchema, min 1)
- Add a `.refine()` on ConfigSchema to validate:
  (a) Every chain entry's `provider` references an existing provider id
  (b) `defaultChain` references an existing chain name
- Export all schemas.

**src/config/types.ts** -- Inferred types:
- `export type Config = z.infer<typeof ConfigSchema>`
- `export type ProviderConfig = z.infer<typeof ProviderSchema>`
- `export type ChainConfig = z.infer<typeof ChainSchema>`
- `export type ChainEntryConfig = z.infer<typeof ChainEntrySchema>`
- `export type Settings = z.infer<typeof SettingsSchema>`
- Re-export schemas from schema.ts for convenience.

**src/config/loader.ts** -- Config loading:
- `loadConfig(path: string): Config` -- reads file with `readFileSync`, parses with `yaml.parse()`, validates with `ConfigSchema.safeParse()`. On failure, log errors using `z.prettifyError(result.error)` (Zod v4 API) and throw a `ConfigError`. On success, return `result.data`.
- `resolveConfigPath(): string` -- checks (in order): `--config` CLI arg, `CONFIG_PATH` env var, `./config/config.yaml` default. Uses `process.argv` to find `--config`.

**src/shared/errors.ts** -- Custom error classes:
- `ConfigError extends Error` -- config validation or loading errors
- `ProviderError extends Error` -- generic provider failure. Fields: `providerId: string`, `model: string`, `statusCode: number`, `responseBody: string`
- `ProviderRateLimitError extends ProviderError` -- specifically 429. Additional field: `headers: Headers` (raw response headers for retry-after extraction)
- `AllProvidersExhaustedError extends Error` -- all chain entries failed. Field: `attempts: AttemptRecord[]` where `AttemptRecord = { provider: string; model: string; error: string; skipped?: boolean; retryAfter?: number }`. Has a `toOpenAIError()` method that builds the "Tried N providers: ..." message in OpenAI error format.

**src/shared/logger.ts** -- Pino logger:
- Create and export a Pino logger instance.
- Configure with `redact: { paths: ['req.headers.authorization', 'req.headers["api-key"]', '*.apiKey', '*.api_key'], censor: '[REDACTED]' }`.
- Log level from `LOG_LEVEL` env var or default 'info'.
- Name: '429chain'.

**src/shared/types.ts** -- OpenAI-compatible types:
- `ChatCompletionRequest` interface: model (string), messages (array of {role, content, name?, tool_calls?, tool_call_id?}), temperature?, max_tokens?, top_p?, stop?, stream?, tools?, tool_choice?, response_format?, n?, presence_penalty?, frequency_penalty?
- `ChatCompletionResponse` interface: id, object ('chat.completion'), created (number), model, choices (array of {index, message: {role, content, tool_calls?}, finish_reason}), usage ({prompt_tokens, completion_tokens, total_tokens}), system_fingerprint?
- `OpenAIErrorResponse` interface: error: { message, type, param, code }
- `ModelsResponse` interface: object ('list'), data (array of {id, object ('model'), created, owned_by})
- `AttemptRecord` interface: provider, model, error, skipped?, retryAfter?

**config/config.example.yaml** -- Example config with comments:
```yaml
# 429chain configuration
version: 1

settings:
  port: 3429
  apiKeys:
    - "your-proxy-api-key-here"  # API key(s) that clients use to access this proxy
  defaultChain: "default"
  logLevel: info
  cooldownDefaultMs: 60000       # Default cooldown on 429 (ms)
  requestTimeoutMs: 30000        # Upstream request timeout (ms)

providers:
  - id: openrouter
    name: OpenRouter
    type: openrouter
    apiKey: "sk-or-v1-your-key-here"
    # baseUrl defaults to https://openrouter.ai/api/v1

  - id: groq
    name: Groq
    type: groq
    apiKey: "gsk_your-key-here"
    # baseUrl defaults to https://api.groq.com/openai/v1

  - id: cerebras
    name: Cerebras
    type: cerebras
    apiKey: "csk-your-key-here"
    # baseUrl defaults to https://api.cerebras.ai/v1

chains:
  - name: default
    entries:
      - provider: openrouter
        model: "meta-llama/llama-3.1-8b-instruct:free"
      - provider: groq
        model: "llama-3.1-8b-instant"
      - provider: cerebras
        model: "llama-3.1-8b"

  - name: fast
    entries:
      - provider: groq
        model: "llama-3.1-8b-instant"
      - provider: cerebras
        model: "llama-3.1-8b"
```

IMPORTANT notes for implementation:
- Use Zod v4 API: `z.prettifyError()` for human-readable errors (not `fromZodError` or v3 formatting)
- All imports use ESM syntax (import/export)
- Logger redaction is critical -- configure it before any other code runs
- The `AttemptRecord` type in shared/types.ts is used by `AllProvidersExhaustedError` in errors.ts -- make sure the import works
  </action>
  <verify>
1. Run `npx tsc --noEmit` -- should pass with zero errors.
2. Run `npx vitest run` -- should pass (no test files yet, but no crash).
3. Create a quick smoke test: write a small test file that imports `loadConfig` and tries to load config.example.yaml (after copying it to config/config.yaml). Verify it returns a valid Config object. Then test with invalid YAML to verify error output.
  </verify>
  <done>
All foundation files compile. Config loading validates YAML against Zod schema and returns typed Config. Logger redacts API keys. Error classes produce OpenAI-format errors. All types exported for use by Plans 02-04.
  </done>
</task>

</tasks>

<verification>
1. `npm install` completes successfully
2. `npx tsc --noEmit` passes with zero errors
3. All exports are importable: `import { loadConfig } from './config/loader'`, `import { logger } from './shared/logger'`, `import { AllProvidersExhaustedError } from './shared/errors'`, `import type { Config, ChatCompletionRequest } from ...`
4. Loading config.example.yaml (with values filled in) returns a valid Config object
5. Loading malformed YAML prints readable Zod errors
6. Logger output is JSON and authorization values are replaced with [REDACTED]
</verification>

<success_criteria>
- Project builds with `tsc --noEmit` (zero errors)
- Config schema validates correct YAML and rejects invalid YAML with readable errors
- Cross-references validated (chain entries reference existing providers, defaultChain references existing chain)
- Logger configured with secret redaction before any other code runs
- All shared types and error classes exported and usable by subsequent plans
</success_criteria>

<output>
After completion, create `.planning/phases/01-core-waterfall-proxy/01-01-SUMMARY.md`
</output>
