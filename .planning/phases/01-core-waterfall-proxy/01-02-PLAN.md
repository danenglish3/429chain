---
phase: 01-core-waterfall-proxy
plan: 02
type: execute
wave: 2
depends_on: ["01-01"]
files_modified:
  - src/providers/types.ts
  - src/providers/base-adapter.ts
  - src/providers/adapters/openrouter.ts
  - src/providers/adapters/groq.ts
  - src/providers/adapters/cerebras.ts
  - src/providers/registry.ts
autonomous: true

must_haves:
  truths:
    - "Each provider adapter can send a non-streaming chat completion request and return a normalized ProviderResponse"
    - "Each provider adapter parses its own rate limit headers into a common RateLimitInfo shape"
    - "The provider registry resolves a provider ID to the correct adapter instance"
    - "Provider-specific quirks (Cerebras unsupported params, OpenRouter extra headers) are handled in their respective adapters"
  artifacts:
    - path: "src/providers/types.ts"
      provides: "ProviderAdapter interface, ProviderResponse, RateLimitInfo"
      exports: ["ProviderAdapter", "ProviderResponse", "RateLimitInfo"]
    - path: "src/providers/base-adapter.ts"
      provides: "Abstract base adapter with shared fetch logic"
      exports: ["BaseAdapter"]
    - path: "src/providers/adapters/openrouter.ts"
      provides: "OpenRouter adapter with X-RateLimit-* header parsing"
      exports: ["OpenRouterAdapter"]
    - path: "src/providers/adapters/groq.ts"
      provides: "Groq adapter with x-ratelimit-*-requests/tokens parsing"
      exports: ["GroqAdapter"]
    - path: "src/providers/adapters/cerebras.ts"
      provides: "Cerebras adapter with x-ratelimit-*-day/minute parsing and param stripping"
      exports: ["CerebrasAdapter"]
    - path: "src/providers/registry.ts"
      provides: "Map of provider type -> adapter factory, buildRegistry from config"
      exports: ["buildRegistry", "ProviderRegistry"]
  key_links:
    - from: "src/providers/base-adapter.ts"
      to: "src/providers/types.ts"
      via: "implements ProviderAdapter"
      pattern: "implements ProviderAdapter"
    - from: "src/providers/adapters/openrouter.ts"
      to: "src/providers/base-adapter.ts"
      via: "extends BaseAdapter"
      pattern: "extends BaseAdapter"
    - from: "src/providers/registry.ts"
      to: "src/config/types.ts"
      via: "builds from ProviderConfig[]"
      pattern: "ProviderConfig"
---

<objective>
Build the provider adapter layer: a ProviderAdapter interface, a base adapter with shared HTTP request logic, three concrete adapters (OpenRouter, Groq, Cerebras) with provider-specific header parsing and quirk handling, and a registry that maps provider IDs to adapter instances.

Purpose: The chain router (Plan 03) and HTTP endpoints (Plan 04) depend on being able to call providers through a uniform interface. This plan creates that abstraction so the rest of the system never deals with provider differences directly.
Output: A complete provider adapter layer with registry, ready for the chain router to iterate through.
</objective>

<execution_context>
@C:\Users\danen\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\danen\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-core-waterfall-proxy/01-RESEARCH.md
@.planning/phases/01-core-waterfall-proxy/01-01-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Provider types, base adapter, and three concrete adapters</name>
  <files>
    src/providers/types.ts
    src/providers/base-adapter.ts
    src/providers/adapters/openrouter.ts
    src/providers/adapters/groq.ts
    src/providers/adapters/cerebras.ts
  </files>
  <action>
Create the provider adapter interface, shared base class, and all three provider adapters.

**src/providers/types.ts** -- Core adapter types:
- `ProviderAdapter` interface:
  - `readonly id: string` -- provider instance ID (from config)
  - `readonly providerType: string` -- 'openrouter' | 'groq' | 'cerebras' | 'generic-openai'
  - `readonly name: string` -- display name
  - `readonly baseUrl: string` -- API base URL
  - `chatCompletion(model: string, body: ChatCompletionRequest, signal?: AbortSignal): Promise<ProviderResponse>` -- send non-streaming request
  - `parseRateLimitHeaders(headers: Headers): RateLimitInfo | null` -- extract rate limit data
  - `getExtraHeaders(): Record<string, string>` -- provider-specific headers (e.g., OpenRouter's X-Title)

- `ProviderResponse` interface:
  - `status: number`
  - `body: ChatCompletionResponse`
  - `headers: Headers`
  - `latencyMs: number`

- `RateLimitInfo` interface (normalized across all providers):
  - `limitRequests?: number` -- max requests in window
  - `remainingRequests?: number` -- requests remaining
  - `resetRequestsMs?: number` -- ms until request limit resets
  - `limitTokens?: number` -- max tokens in window
  - `remainingTokens?: number` -- tokens remaining
  - `resetTokensMs?: number` -- ms until token limit resets
  - `retryAfterMs?: number` -- explicit retry-after from 429

**src/providers/base-adapter.ts** -- Abstract base:
- Constructor takes: `id`, `providerType`, `name`, `apiKey`, `baseUrl`
- `chatCompletion()` implementation:
  1. Build URL: `${this.baseUrl}/chat/completions`
  2. Build headers: `Content-Type: application/json`, `Authorization: Bearer ${this.apiKey}`, spread `this.getExtraHeaders()`
  3. Build body: call `this.prepareRequestBody(model, body)` (virtual method, allows adapters to strip unsupported params)
  4. Set `stream: false` in body (Phase 1: non-streaming only)
  5. Call `fetch(url, { method: 'POST', headers, body: JSON.stringify(requestBody), signal })` with native fetch
  6. Measure latency with `performance.now()`
  7. If response.status === 429: throw `ProviderRateLimitError(this.id, model, response.headers)`
  8. If !response.ok: read response body as text, throw `ProviderError(this.id, model, response.status, errorText)`
  9. Parse JSON response, return `{ status, body, headers, latencyMs }`
- `prepareRequestBody(model: string, body: ChatCompletionRequest): object` -- default implementation: `{ model, ...body, stream: false }`. Adapters override to strip params.
- `getExtraHeaders()` -- default returns empty object `{}`
- `parseRateLimitHeaders()` -- abstract, each adapter implements

**src/providers/adapters/openrouter.ts** -- OpenRouterAdapter extends BaseAdapter:
- Default baseUrl: `https://openrouter.ai/api/v1`
- `getExtraHeaders()`: return `{ 'HTTP-Referer': '429chain', 'X-Title': '429chain' }` (identifies the app to OpenRouter for analytics)
- `parseRateLimitHeaders(headers)`: Parse OpenRouter format:
  - `X-RateLimit-Limit` -> limitRequests
  - `X-RateLimit-Remaining` -> remainingRequests
  - `X-RateLimit-Reset` -> convert from Unix timestamp in MILLISECONDS to ms-from-now for resetRequestsMs
  - Return null if none of these headers present

**src/providers/adapters/groq.ts** -- GroqAdapter extends BaseAdapter:
- Default baseUrl: `https://api.groq.com/openai/v1`
- `parseRateLimitHeaders(headers)`: Parse Groq format:
  - `x-ratelimit-limit-requests` -> limitRequests
  - `x-ratelimit-remaining-requests` -> remainingRequests
  - `x-ratelimit-reset-requests` -> parse duration string to ms for resetRequestsMs
  - `x-ratelimit-limit-tokens` -> limitTokens
  - `x-ratelimit-remaining-tokens` -> remainingTokens
  - `x-ratelimit-reset-tokens` -> parse duration string to ms for resetTokensMs
  - `retry-after` (only on 429) -> retryAfterMs (seconds * 1000)
  - Return null if none present

**src/providers/adapters/cerebras.ts** -- CerebrasAdapter extends BaseAdapter:
- Default baseUrl: `https://api.cerebras.ai/v1`
- `prepareRequestBody()` override: Strip `presence_penalty` and `frequency_penalty` from the request body before sending (Cerebras does not support these). Log a debug warning when stripping.
- `parseRateLimitHeaders(headers)`: Parse Cerebras format:
  - `x-ratelimit-limit-requests-day` -> limitRequests
  - `x-ratelimit-remaining-requests-day` -> remainingRequests
  - `x-ratelimit-reset-requests-day` -> parse seconds to ms for resetRequestsMs
  - `x-ratelimit-limit-tokens-minute` -> limitTokens
  - `x-ratelimit-remaining-tokens-minute` -> remainingTokens
  - `x-ratelimit-reset-tokens-minute` -> parse seconds to ms for resetTokensMs
  - Return null if none present

IMPORTANT notes:
- The apiKey is stored in the adapter instance (passed at construction from config). It is NOT passed per-request. The adapter owns its credentials.
- All adapters use the logger from `src/shared/logger.ts` for debug/error logging.
- Header names are case-insensitive in the `Headers` API -- use `headers.get('x-ratelimit-remaining')` (lowercase is fine, Headers normalizes).
- For Groq's duration strings in reset headers (e.g., "6m23.456s"), parse them manually: extract minutes and seconds, convert to milliseconds. Do NOT use the `ms` package for this -- it doesn't handle "6m23.456s" format. Write a simple `parseDurationToMs(str: string): number` helper in groq.ts.
  </action>
  <verify>
1. `npx tsc --noEmit` passes with zero errors.
2. Each adapter can be instantiated with test config values.
3. Each adapter's `parseRateLimitHeaders()` correctly parses a manually-constructed Headers object with that provider's header format.
  </verify>
  <done>
Three provider adapters (OpenRouter, Groq, Cerebras) implement the ProviderAdapter interface. Each handles its own auth headers, rate limit header parsing, and provider quirks. Base adapter handles shared HTTP fetch logic.
  </done>
</task>

<task type="auto">
  <name>Task 2: Provider registry</name>
  <files>src/providers/registry.ts</files>
  <action>
Create the provider registry that maps provider IDs to adapter instances.

**src/providers/registry.ts**:
- `ProviderRegistry` class:
  - Private `adapters: Map<string, ProviderAdapter>`
  - `get(providerId: string): ProviderAdapter` -- returns adapter or throws descriptive error ("Provider 'xyz' not found in registry. Available: a, b, c")
  - `has(providerId: string): boolean`
  - `getAll(): ProviderAdapter[]` -- returns all adapters (for /v1/models endpoint)
  - `size: number` getter

- `buildRegistry(providers: ProviderConfig[]): ProviderRegistry` -- factory function:
  - For each provider config, create the correct adapter based on `type`:
    - 'openrouter' -> new OpenRouterAdapter(config.id, config.name, config.apiKey, config.baseUrl)
    - 'groq' -> new GroqAdapter(config.id, config.name, config.apiKey, config.baseUrl)
    - 'cerebras' -> new CerebrasAdapter(config.id, config.name, config.apiKey, config.baseUrl)
    - 'generic-openai' -> new BaseAdapter subclass or a GenericOpenAIAdapter that does no special header parsing and requires baseUrl
  - If baseUrl is not provided, each adapter uses its default.
  - Throw ConfigError if a provider type is unknown.
  - Log info: "Registered provider: {name} ({type}) at {baseUrl}"

Note: The registry is built once at startup from the validated config. It does not change at runtime in Phase 1.
  </action>
  <verify>
1. `npx tsc --noEmit` passes.
2. `buildRegistry()` with a valid ProviderConfig[] returns a ProviderRegistry with the correct number of entries.
3. `registry.get('nonexistent')` throws a descriptive error.
  </verify>
  <done>
Provider registry maps config provider IDs to concrete adapter instances. Factory function builds registry from validated config at startup.
  </done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit` passes with all provider files
2. Each adapter correctly implements the ProviderAdapter interface
3. OpenRouter adapter adds HTTP-Referer and X-Title headers
4. Cerebras adapter strips presence_penalty from request body
5. Each adapter's parseRateLimitHeaders handles its provider's header format
6. Registry builds from config and resolves provider IDs to correct adapters
7. Unknown provider type throws ConfigError
</verification>

<success_criteria>
- All three provider adapters compile and implement ProviderAdapter correctly
- Provider-specific header parsing is isolated in each adapter (no if/else on provider type outside adapters)
- Registry factory builds from ProviderConfig[] and provides O(1) lookup by provider ID
- Base adapter handles shared HTTP logic (fetch, error detection, latency measurement)
</success_criteria>

<output>
After completion, create `.planning/phases/01-core-waterfall-proxy/01-02-SUMMARY.md`
</output>
