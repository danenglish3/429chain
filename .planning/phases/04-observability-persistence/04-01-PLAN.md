---
phase: 04-observability-persistence
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - package.json
  - src/config/schema.ts
  - src/persistence/db.ts
  - src/persistence/schema.ts
  - src/persistence/request-logger.ts
  - src/persistence/aggregator.ts
autonomous: true

must_haves:
  truths:
    - "SQLite database can be initialized with WAL mode and performance pragmas"
    - "Schema migration creates all tables, indexes, and triggers on first run"
    - "RequestLogger can insert a request log entry via prepared statement"
    - "UsageAggregator can read provider and chain usage totals from materialized tables"
    - "Database path is configurable via settings.dbPath with sensible default"
  artifacts:
    - path: "src/persistence/db.ts"
      provides: "Database initialization with WAL mode"
      exports: ["initializeDatabase"]
    - path: "src/persistence/schema.ts"
      provides: "Schema migration with user_version pragma"
      exports: ["migrateSchema"]
    - path: "src/persistence/request-logger.ts"
      provides: "Fire-and-forget request log insertion"
      exports: ["RequestLogger", "RequestLogEntry"]
    - path: "src/persistence/aggregator.ts"
      provides: "Usage aggregation reads from materialized tables"
      exports: ["UsageAggregator", "ProviderUsage", "ChainUsage"]
  key_links:
    - from: "src/persistence/db.ts"
      to: "better-sqlite3"
      via: "import Database from 'better-sqlite3'"
      pattern: "import Database from 'better-sqlite3'"
    - from: "src/persistence/schema.ts"
      to: "src/persistence/db.ts"
      via: "receives Database.Database instance"
      pattern: "db\\.exec|db\\.pragma"
    - from: "src/persistence/request-logger.ts"
      to: "src/persistence/db.ts"
      via: "receives Database.Database instance, uses prepared statement"
      pattern: "db\\.prepare"
    - from: "src/persistence/aggregator.ts"
      to: "src/persistence/db.ts"
      via: "receives Database.Database instance, reads materialized tables"
      pattern: "db\\.prepare"
---

<objective>
Create the SQLite persistence module for 429chain observability.

Purpose: This is the data foundation for request logging and usage tracking. All subsequent plans (request logging wiring, stats API endpoints) depend on these modules existing.

Output: Four new files in src/persistence/ (db.ts, schema.ts, request-logger.ts, aggregator.ts), updated config schema with dbPath setting, better-sqlite3 installed.
</objective>

<execution_context>
@C:\Users\danen\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\danen\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-observability-persistence/04-RESEARCH.md
@src/config/schema.ts
@src/config/types.ts
@src/shared/types.ts (Usage interface)
@src/chain/types.ts (ChainResult, StreamChainResult)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Install better-sqlite3 and update config schema</name>
  <files>package.json, src/config/schema.ts</files>
  <action>
1. Install better-sqlite3 and its type definitions:
   ```
   npm install better-sqlite3
   npm install -D @types/better-sqlite3
   ```

2. In `src/config/schema.ts`, add `dbPath` to the `SettingsSchema` object:
   - `dbPath: z.string().default('./data/observability.db')` -- path to SQLite database file
   - Place it after `requestTimeoutMs` in the schema
   - This makes the DB path configurable via YAML config under settings.dbPath

Note: The `types.ts` file auto-infers from the schema via `z.infer`, so no changes needed there.
  </action>
  <verify>
Run `npx tsc --noEmit` to confirm no type errors. Verify better-sqlite3 appears in package.json dependencies and @types/better-sqlite3 in devDependencies.
  </verify>
  <done>better-sqlite3 installed, config schema accepts optional dbPath with default './data/observability.db', TypeScript compiles clean.</done>
</task>

<task type="auto">
  <name>Task 2: Create persistence module (db, schema, request-logger, aggregator)</name>
  <files>src/persistence/db.ts, src/persistence/schema.ts, src/persistence/request-logger.ts, src/persistence/aggregator.ts</files>
  <action>
Create `src/persistence/db.ts`:
- Export `initializeDatabase(dbPath: string): Database.Database`
- Import Database from 'better-sqlite3'
- Import logger from '../shared/logger.js'
- Ensure parent directory exists using `import { mkdirSync } from 'node:fs'` and `import { dirname } from 'node:path'` -- call `mkdirSync(dirname(dbPath), { recursive: true })` before opening DB
- Create Database instance with the given path
- Set pragmas: `journal_mode = WAL`, `synchronous = NORMAL`, `cache_size = -64000`, `temp_store = MEMORY`
- Log the DB path and WAL mode at info level
- Return the db instance

Create `src/persistence/schema.ts`:
- Export `migrateSchema(db: Database.Database): void`
- Import type Database from 'better-sqlite3'
- Import logger from '../shared/logger.js'
- Read current version via `db.pragma('user_version', { simple: true })` cast to number
- Define migrations array with one entry (version 0 -> 1):
  - Migration 1 creates ALL tables, indexes, and triggers in a single `db.exec()` call:
    - `request_logs` table: id INTEGER PRIMARY KEY AUTOINCREMENT, timestamp INTEGER NOT NULL, chain_name TEXT NOT NULL, provider_id TEXT NOT NULL, model TEXT NOT NULL, prompt_tokens INTEGER NOT NULL DEFAULT 0, completion_tokens INTEGER NOT NULL DEFAULT 0, total_tokens INTEGER NOT NULL DEFAULT 0, latency_ms INTEGER NOT NULL, http_status INTEGER NOT NULL, attempts INTEGER NOT NULL
    - `usage_by_provider` table: provider_id TEXT PRIMARY KEY, total_requests INTEGER NOT NULL DEFAULT 0, total_tokens INTEGER NOT NULL DEFAULT 0, total_prompt_tokens INTEGER NOT NULL DEFAULT 0, total_completion_tokens INTEGER NOT NULL DEFAULT 0, last_request_timestamp INTEGER
    - `usage_by_chain` table: chain_name TEXT PRIMARY KEY, total_requests INTEGER NOT NULL DEFAULT 0, total_tokens INTEGER NOT NULL DEFAULT 0, total_prompt_tokens INTEGER NOT NULL DEFAULT 0, total_completion_tokens INTEGER NOT NULL DEFAULT 0, last_request_timestamp INTEGER
    - Index: `idx_logs_timestamp` on request_logs(timestamp DESC)
    - Index: `idx_logs_provider` on request_logs(provider_id, model)
    - Index: `idx_logs_chain` on request_logs(chain_name)
    - Trigger: `update_provider_usage` AFTER INSERT ON request_logs -- uses INSERT ... ON CONFLICT DO UPDATE to upsert usage_by_provider (increment total_requests by 1, add token counts, MAX on last_request_timestamp)
    - Trigger: `update_chain_usage` AFTER INSERT ON request_logs -- same pattern for usage_by_chain
  - Use `CREATE TABLE IF NOT EXISTS`, `CREATE INDEX IF NOT EXISTS`, `CREATE TRIGGER IF NOT EXISTS` for idempotency
- Loop from currentVersion to migrations.length, running each migration and setting `user_version = i + 1`
- Log migration progress at info level

Create `src/persistence/request-logger.ts`:
- Export interface `RequestLogEntry` with fields: timestamp (number), chainName (string), providerId (string), model (string), promptTokens (number), completionTokens (number), totalTokens (number), latencyMs (number), httpStatus (number), attempts (number)
- Export class `RequestLogger`:
  - Constructor receives `db: Database.Database`
  - Create prepared statement in constructor: `INSERT INTO request_logs (timestamp, chain_name, provider_id, model, prompt_tokens, completion_tokens, total_tokens, latency_ms, http_status, attempts) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?)`
  - Method `logRequest(entry: RequestLogEntry): void` -- runs the prepared statement with entry values. Uses positional params: timestamp, chainName, providerId, model, promptTokens, completionTokens, totalTokens, Math.round(latencyMs), httpStatus, attempts

Create `src/persistence/aggregator.ts`:
- Export interface `ProviderUsage`: providerId (string), totalRequests (number), totalTokens (number), totalPromptTokens (number), totalCompletionTokens (number), lastRequestTimestamp (number | null)
- Export interface `ChainUsage`: chainName (string), totalRequests (number), totalTokens (number), totalPromptTokens (number), totalCompletionTokens (number), lastRequestTimestamp (number | null)
- Export class `UsageAggregator`:
  - Constructor receives `db: Database.Database`
  - Create 4 prepared statements in constructor:
    1. Get all provider usage: `SELECT provider_id as providerId, total_requests as totalRequests, total_tokens as totalTokens, total_prompt_tokens as totalPromptTokens, total_completion_tokens as totalCompletionTokens, last_request_timestamp as lastRequestTimestamp FROM usage_by_provider ORDER BY last_request_timestamp DESC`
    2. Get single provider usage: same SELECT with `WHERE provider_id = ?`
    3. Get all chain usage: `SELECT chain_name as chainName, total_requests as totalRequests, total_tokens as totalTokens, total_prompt_tokens as totalPromptTokens, total_completion_tokens as totalCompletionTokens, last_request_timestamp as lastRequestTimestamp FROM usage_by_chain ORDER BY last_request_timestamp DESC`
    4. Get single chain usage: same SELECT with `WHERE chain_name = ?`
  - Methods:
    - `getAllProviderUsage(): ProviderUsage[]` -- returns stmt.all() cast to ProviderUsage[]
    - `getProviderUsage(providerId: string): ProviderUsage | null` -- returns stmt.get(providerId) cast, or null
    - `getAllChainUsage(): ChainUsage[]` -- returns stmt.all() cast to ChainUsage[]
    - `getChainUsage(chainName: string): ChainUsage | null` -- returns stmt.get(chainName) cast, or null
    - `getRecentRequests(limit: number = 50): RequestLogRow[]` -- SELECT * FROM request_logs ORDER BY timestamp DESC LIMIT ? -- useful for request log display
  - Export interface `RequestLogRow` with all columns from request_logs using camelCase aliases

All files use ESM imports with .js extensions per project convention (d002).
  </action>
  <verify>
Run `npx tsc --noEmit` to confirm all persistence files compile cleanly. Verify all exports are accessible: `import { initializeDatabase } from './persistence/db.js'`, `import { migrateSchema } from './persistence/schema.js'`, etc.
  </verify>
  <done>All four persistence module files exist, compile, and export the expected classes/functions/interfaces. Schema includes all tables (request_logs, usage_by_provider, usage_by_chain), all indexes (timestamp, provider, chain), and both triggers (update_provider_usage, update_chain_usage). Migration system uses PRAGMA user_version.</done>
</task>

</tasks>

<verification>
- `npx tsc --noEmit` passes with zero errors
- better-sqlite3 in package.json dependencies, @types/better-sqlite3 in devDependencies
- `src/persistence/db.ts` exports `initializeDatabase`
- `src/persistence/schema.ts` exports `migrateSchema`
- `src/persistence/request-logger.ts` exports `RequestLogger` class and `RequestLogEntry` interface
- `src/persistence/aggregator.ts` exports `UsageAggregator` class, `ProviderUsage`, `ChainUsage`, `RequestLogRow` interfaces
- Config schema accepts `dbPath` in settings with default value
</verification>

<success_criteria>
- SQLite persistence module is complete and compiles
- Schema defines request_logs + materialized aggregation tables + triggers + indexes
- RequestLogger provides prepared-statement insert for fire-and-forget logging
- UsageAggregator provides O(1) reads from materialized tables
- Config schema updated with dbPath setting
- No existing tests broken
</success_criteria>

<output>
After completion, create `.planning/phases/04-observability-persistence/04-01-SUMMARY.md`
</output>
