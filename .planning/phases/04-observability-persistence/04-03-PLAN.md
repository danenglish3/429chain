---
phase: 04-observability-persistence
plan: 03
type: execute
wave: 3
depends_on: ["04-02"]
files_modified:
  - src/api/routes/stats.ts
  - src/api/routes/ratelimits.ts
  - src/index.ts
autonomous: true

must_haves:
  truths:
    - "Users can query aggregate usage totals per provider (total tokens, total requests)"
    - "Users can query aggregate usage totals per chain (total tokens, total requests)"
    - "Users can see live rate limit status for each provider -- remaining quota, cooldown status"
    - "All stats and rate limit endpoints require API key authentication"
    - "Recent request log entries are queryable for debugging"
  artifacts:
    - path: "src/api/routes/stats.ts"
      provides: "GET /v1/stats/providers, /v1/stats/providers/:providerId, /v1/stats/chains, /v1/stats/chains/:chainName, /v1/stats/requests"
      exports: ["createStatsRoutes"]
    - path: "src/api/routes/ratelimits.ts"
      provides: "GET /v1/ratelimits endpoint"
      exports: ["createRateLimitRoutes"]
    - path: "src/index.ts"
      provides: "Mounts stats and ratelimits routes under auth-protected /v1"
      contains: "createStatsRoutes"
  key_links:
    - from: "src/api/routes/stats.ts"
      to: "src/persistence/aggregator.ts"
      via: "receives UsageAggregator, calls getAllProviderUsage, getProviderUsage, etc."
      pattern: "aggregator\\.(getAll|get)"
    - from: "src/api/routes/ratelimits.ts"
      to: "src/ratelimit/tracker.ts"
      via: "receives RateLimitTracker, calls getAllStatuses()"
      pattern: "tracker\\.getAllStatuses"
    - from: "src/index.ts"
      to: "src/api/routes/stats.ts"
      via: "imports createStatsRoutes, mounts on v1 sub-app"
      pattern: "v1\\.route.*stats"
    - from: "src/index.ts"
      to: "src/api/routes/ratelimits.ts"
      via: "imports createRateLimitRoutes, mounts on v1 sub-app"
      pattern: "v1\\.route.*ratelimits"
---

<objective>
Create stats and rate limit status API endpoints, and mount them into the Hono application.

Purpose: This is the query layer for observability. Users can see aggregate usage data (per-provider and per-chain totals), browse recent request logs, and view live rate limit status for all tracked provider+model pairs. These endpoints complete the OBSV-01 through OBSV-04 requirements.

Output: Two new route files (stats.ts, ratelimits.ts) and updated index.ts with route mounting.
</objective>

<execution_context>
@C:\Users\danen\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\danen\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-observability-persistence/04-RESEARCH.md
@.planning/phases/04-observability-persistence/04-01-SUMMARY.md
@.planning/phases/04-observability-persistence/04-02-SUMMARY.md
@src/index.ts
@src/persistence/aggregator.ts
@src/ratelimit/tracker.ts
@src/ratelimit/types.ts (CooldownEntry, QuotaInfo)
@src/api/routes/health.ts (pattern reference for route factory)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create stats and rate limit status route files</name>
  <files>src/api/routes/stats.ts, src/api/routes/ratelimits.ts</files>
  <action>
Create `src/api/routes/stats.ts`:
- Import Hono from 'hono'
- Import type UsageAggregator from '../../persistence/aggregator.js'
- Export function `createStatsRoutes(aggregator: UsageAggregator)` returning a Hono sub-app
- Follow the route factory pattern (d007) used by health.ts, chat.ts, models.ts

Endpoints:
1. `GET /providers` -- returns `{ providers: aggregator.getAllProviderUsage() }`
2. `GET /providers/:providerId` -- returns single provider usage or 404 `{ error: 'No usage data for provider' }`
   - Get providerId from `c.req.param('providerId')`
   - Call `aggregator.getProviderUsage(providerId)`
   - If null, return 404 with error message
   - Otherwise return the usage object directly
3. `GET /chains` -- returns `{ chains: aggregator.getAllChainUsage() }`
4. `GET /chains/:chainName` -- returns single chain usage or 404 `{ error: 'No usage data for chain' }`
   - Same pattern as provider endpoint
5. `GET /requests` -- returns `{ requests: aggregator.getRecentRequests(limit) }`
   - Parse optional `limit` query param: `const limit = Number(c.req.query('limit')) || 50`
   - Cap at 500 maximum: `Math.min(limit, 500)`

All endpoints return JSON. No additional validation needed -- the aggregator handles empty results gracefully.

Create `src/api/routes/ratelimits.ts`:
- Import Hono from 'hono'
- Import type RateLimitTracker from '../../ratelimit/tracker.js'
- Export function `createRateLimitRoutes(tracker: RateLimitTracker)` returning a Hono sub-app

Endpoint:
1. `GET /` -- returns live rate limit status for all tracked provider+model pairs
   - Call `tracker.getAllStatuses()`
   - Map each CooldownEntry to a response object:
     ```typescript
     {
       ratelimits: statuses.map(entry => ({
         provider: entry.providerId,
         model: entry.model,
         status: entry.status,
         cooldownUntil: entry.cooldownUntil,
         reason: entry.reason,
         quota: entry.quota ? {
           remainingRequests: entry.quota.remainingRequests,
           remainingTokens: entry.quota.remainingTokens,
           resetRequestsMs: entry.quota.resetRequestsMs,
           resetTokensMs: entry.quota.resetTokensMs,
           lastUpdated: entry.quota.lastUpdated,
         } : null,
       })),
     }
     ```
   - This gives users visibility into: which providers are available/tracking/exhausted, their remaining quota if tracked, cooldown timers if exhausted

Both files should have JSDoc module comments following the existing convention (see health.ts for reference).
  </action>
  <verify>
Run `npx tsc --noEmit` to confirm both files compile cleanly. Verify exports: `createStatsRoutes` from stats.ts and `createRateLimitRoutes` from ratelimits.ts.
  </verify>
  <done>Stats routes provide 5 endpoints for provider usage, chain usage, and recent requests. Rate limit routes provide 1 endpoint for live provider+model status. Both follow the route factory pattern.</done>
</task>

<task type="auto">
  <name>Task 2: Mount stats and ratelimits routes into the application</name>
  <files>src/index.ts</files>
  <action>
Modify `src/index.ts` to create the UsageAggregator and mount both new route sub-apps.

**Add imports** (alongside the existing persistence imports from 04-02):
```typescript
import { UsageAggregator } from './persistence/aggregator.js';
import { createStatsRoutes } from './api/routes/stats.js';
import { createRateLimitRoutes } from './api/routes/ratelimits.js';
```

**Create aggregator** after the requestLogger creation (within the DB initialization block):
```typescript
const aggregator = new UsageAggregator(db);
```

**Mount routes** in the auth-protected v1 section, after the existing chatRoutes and modelsRoutes mounting:
```typescript
const statsRoutes = createStatsRoutes(aggregator);
const rateLimitRoutes = createRateLimitRoutes(tracker);

v1.route('/stats', statsRoutes);
v1.route('/ratelimits', rateLimitRoutes);
```

This means the full URL paths will be:
- GET /v1/stats/providers
- GET /v1/stats/providers/:providerId
- GET /v1/stats/chains
- GET /v1/stats/chains/:chainName
- GET /v1/stats/requests
- GET /v1/ratelimits

All protected by the existing auth middleware (d008) since they're mounted under the v1 sub-app which has `v1.use('*', auth)`.

**Update the Ready log** to include database info for visibility:
In the serve callback, update the Ready log to include `dbPath: config.settings.dbPath`:
```typescript
logger.info(
  {
    providers: registry.size,
    chains: chains.size,
    defaultChain: config.settings.defaultChain,
    dbPath: config.settings.dbPath,
  },
  'Ready',
);
```
  </action>
  <verify>
Run `npx tsc --noEmit` to confirm no type errors. Run `npm test` to verify existing tests pass. Start the server briefly with `npx tsx src/index.ts` and verify:
1. Database file is created at the configured path
2. Log output shows DB initialization and "Ready" with dbPath
3. Ctrl+C triggers graceful shutdown with "Database closed" log
  </verify>
  <done>All observability endpoints are mounted under /v1 with auth protection. Stats endpoints read from materialized aggregation tables (O(1) query time). Rate limit endpoint reads from in-memory tracker state. The full observability stack is operational: request logging writes + aggregation triggers + query endpoints.</done>
</task>

</tasks>

<verification>
- `npx tsc --noEmit` passes with zero errors
- `npm test` passes (existing tests still work)
- Stats routes mounted at /v1/stats/* (5 endpoints)
- Rate limit routes mounted at /v1/ratelimits (1 endpoint)
- All new endpoints require API key authentication (under v1 sub-app)
- UsageAggregator created from same db instance as RequestLogger
- Server Ready log includes dbPath for configuration visibility
</verification>

<success_criteria>
- GET /v1/stats/providers returns aggregate usage per provider (OBSV-02)
- GET /v1/stats/chains returns aggregate usage per chain (OBSV-03)
- GET /v1/stats/requests returns recent request log entries (OBSV-01 query)
- GET /v1/ratelimits returns live rate limit status with quota info and cooldown timers (OBSV-04)
- All endpoints return JSON with consistent structure
- All endpoints protected by API key auth
- Unauthorized requests receive 401 (existing auth middleware)
</success_criteria>

<output>
After completion, create `.planning/phases/04-observability-persistence/04-03-SUMMARY.md`
</output>
