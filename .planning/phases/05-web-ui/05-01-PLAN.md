---
phase: 05-web-ui
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/api/routes/admin.ts
  - src/config/writer.ts
  - src/index.ts
autonomous: true

must_haves:
  truths:
    - "GET /v1/admin/config returns current providers and chains from running config"
    - "PUT /v1/admin/providers/:id creates or updates a provider and persists to YAML"
    - "DELETE /v1/admin/providers/:id removes a provider and persists to YAML"
    - "PUT /v1/admin/chains/:name creates or updates a chain and persists to YAML"
    - "DELETE /v1/admin/chains/:name removes a chain and persists to YAML"
    - "Invalid provider/chain payloads return 400 with Zod validation errors"
  artifacts:
    - path: "src/api/routes/admin.ts"
      provides: "Admin CRUD route factory"
      exports: ["createAdminRoutes"]
    - path: "src/config/writer.ts"
      provides: "Config persistence to YAML file"
      exports: ["writeConfig"]
  key_links:
    - from: "src/api/routes/admin.ts"
      to: "src/config/writer.ts"
      via: "writeConfig call after mutation"
      pattern: "writeConfig"
    - from: "src/api/routes/admin.ts"
      to: "src/config/schema.ts"
      via: "Zod validation of payloads"
      pattern: "ProviderSchema|ChainSchema"
    - from: "src/index.ts"
      to: "src/api/routes/admin.ts"
      via: "route mounting on v1"
      pattern: "createAdminRoutes|admin"
---

<objective>
Create admin CRUD API endpoints for managing providers and chains at runtime, with persistence back to the YAML config file.

Purpose: The Web UI needs backend endpoints to read and mutate the proxy configuration. Currently, config is loaded once from YAML at startup with no mutation API. This plan adds CRUD endpoints under /v1/admin/* that validate payloads using existing Zod schemas, update in-memory state, and persist changes back to YAML.

Output: Admin route factory (src/api/routes/admin.ts), config writer utility (src/config/writer.ts), and route mounting in index.ts.
</objective>

<execution_context>
@C:\Users\danen\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\danen\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

@src/index.ts
@src/config/schema.ts
@src/config/types.ts
@src/config/loader.ts
@src/providers/registry.ts
@src/chain/types.ts
@src/api/routes/stats.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create config writer and admin route factory</name>
  <files>
    src/config/writer.ts
    src/api/routes/admin.ts
  </files>
  <action>
Create `src/config/writer.ts`:
- Export `writeConfig(configPath: string, config: Config): void` that serializes the Config object to YAML using the `yaml` package (already a dependency) and writes it to the file path using `writeFileSync`.
- The writer should produce clean YAML with `yaml.stringify(configObj, { indent: 2 })`.
- The config object written should match the structure that `loadConfig` can read back (version, settings, providers, chains).

Create `src/api/routes/admin.ts`:
- Export `createAdminRoutes(deps)` following the existing route factory pattern (see stats.ts, ratelimits.ts).
- Dependencies needed: `config: Config` (mutable reference), `configPath: string`, `registry: ProviderRegistry`, `chains: Map<string, Chain>`, `tracker: RateLimitTracker`.
- The function must accept a mutable config wrapper object (e.g., `{ current: Config }`) so mutations propagate. Since Config is passed by value in the current codebase, use an object wrapper like `configRef: { current: Config }` that all routes share.

Endpoints to implement:

**GET /config** - Return current config (providers array and chains array, NOT settings/apiKeys for security). Response: `{ providers: [...], chains: [...] }`. Map provider objects to strip apiKey (return `apiKey: "***"` masked).

**PUT /providers/:id** - Create or update a provider.
  - Parse body with `ProviderSchema.safeParse(body)`. On failure, return 400 with `{ error: z.prettifyError(result.error) }`.
  - If provider exists in configRef.current.providers, replace it. Otherwise, push new.
  - Rebuild registry adapter for this provider (call the same adapter creation logic from registry.ts -- you'll need to export `createAdapter` or replicate the switch logic).
  - Call `writeConfig(configPath, configRef.current)` to persist.
  - Return 200 with `{ provider: { ...provider, apiKey: "***" } }`.

**DELETE /providers/:id** - Remove a provider.
  - Check no chains reference this provider. If they do, return 400 with `{ error: "Provider is referenced by chains: [chain names]" }`.
  - Remove from configRef.current.providers array.
  - Remove adapter from registry.
  - Call writeConfig to persist.
  - Return 200 with `{ deleted: id }`.

**PUT /chains/:name** - Create or update a chain.
  - Parse body: expect `{ entries: ChainEntrySchema[] }`. Validate with `z.array(ChainEntrySchema).min(1).safeParse(body.entries)`.
  - Validate all provider IDs in entries exist in registry.
  - If chain exists, replace entries. If new, add to configRef.current.chains.
  - Rebuild the Chain object in the chains Map (use `buildChains` or manual construction).
  - Call writeConfig to persist.
  - Return 200 with `{ chain: { name, entries } }`.

**DELETE /chains/:name** - Remove a chain.
  - Prevent deleting the default chain (configRef.current.settings.defaultChain). Return 400 with `{ error: "Cannot delete default chain" }`.
  - Remove from configRef.current.chains array and chains Map.
  - Call writeConfig to persist.
  - Return 200 with `{ deleted: name }`.

IMPORTANT: Do NOT use `buildChains` from chain/types.ts for single chain updates -- it rebuilds ALL chains. Instead, manually construct a Chain for the updated/new chain and set it in the Map. Look at how `buildChains` works and replicate for a single chain.

IMPORTANT: For the registry, you need to be able to add/remove individual adapters. The current `ProviderRegistry` class has a private `adapters` Map with no add/remove methods. You will need to add `add(id: string, adapter: ProviderAdapter)` and `remove(id: string)` methods to ProviderRegistry in `src/providers/registry.ts`, and export the `createAdapter` function.
  </action>
  <verify>
Run `npx tsc --noEmit` to verify types compile. Check that admin.ts exports createAdminRoutes and writer.ts exports writeConfig.
  </verify>
  <done>
Admin route factory and config writer exist, typecheck passes, all CRUD endpoints are implemented with Zod validation and config persistence.
  </done>
</task>

<task type="auto">
  <name>Task 2: Mount admin routes and wire config reference</name>
  <files>
    src/index.ts
    src/providers/registry.ts
  </files>
  <action>
Update `src/providers/registry.ts`:
- Add `add(id: string, adapter: ProviderAdapter): void` method to ProviderRegistry that sets the adapter in the internal Map.
- Add `remove(id: string): boolean` method that deletes from the Map and returns whether it existed.
- Export the `createAdapter` function (currently private) so admin routes can use it.

Update `src/index.ts`:
- Create a config reference wrapper: `const configRef = { current: config }` right after `const config = loadConfig(configPath)`.
- Import `createAdminRoutes` from `./api/routes/admin.js`.
- Create admin routes: `const adminRoutes = createAdminRoutes(configRef, configPath, registry, chains, tracker)`.
- Mount on v1: `v1.route('/admin', adminRoutes)` -- after the existing v1 route registrations but before `app.route('/v1', v1)`.
- The admin routes are auth-protected (mounted under v1 which already has auth middleware).
  </action>
  <verify>
Run `npx tsc --noEmit` -- should pass with no errors. Run `npm run build` to verify the build succeeds.
  </verify>
  <done>
Admin routes are mounted at /v1/admin/*, protected by auth middleware, and wired to the mutable config reference. ProviderRegistry supports add/remove operations.
  </done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit` passes
2. `npm run build` succeeds
3. Code review: admin.ts follows route factory pattern matching stats.ts/ratelimits.ts
4. Code review: writeConfig produces valid YAML that loadConfig can parse
5. Code review: PUT endpoints validate with Zod schemas, DELETE endpoints check referential integrity
</verification>

<success_criteria>
- GET /v1/admin/config returns providers (masked apiKeys) and chains
- PUT /v1/admin/providers/:id validates with ProviderSchema and persists to YAML
- DELETE /v1/admin/providers/:id rejects if provider is in use by chains
- PUT /v1/admin/chains/:name validates entries and persists to YAML
- DELETE /v1/admin/chains/:name rejects default chain deletion
- All mutations update in-memory state AND write to YAML file
- TypeScript compiles without errors
</success_criteria>

<output>
After completion, create `.planning/phases/05-web-ui/05-01-SUMMARY.md`
</output>
