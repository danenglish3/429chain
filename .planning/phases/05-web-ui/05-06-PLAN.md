---
phase: 05-web-ui
plan: 06
type: execute
wave: 3
depends_on: ["05-02", "05-05"]
files_modified:
  - ui/src/pages/Test.tsx
  - ui/src/pages/Test.module.css
autonomous: false

must_haves:
  truths:
    - "User can type a prompt message in a text area and click Send"
    - "User can optionally select a chain (or use default) before sending"
    - "After sending, user sees which provider served the request"
    - "After sending, user sees the response content"
    - "After sending, user sees the latency in milliseconds"
    - "User sees clear error messages when the request fails"
  artifacts:
    - path: "ui/src/pages/Test.tsx"
      provides: "Test endpoint page with prompt input, chain selection, and response display"
      min_lines: 80
  key_links:
    - from: "ui/src/pages/Test.tsx"
      to: "/v1/chat/completions"
      via: "api.chatCompletion POST request"
      pattern: "chatCompletion"
    - from: "ui/src/pages/Test.tsx"
      to: "/v1/admin/config"
      via: "useQuery to populate chain selector"
      pattern: "useQuery.*config"
---

<objective>
Build the test endpoint page where users can send a prompt and see which provider served it, the response, and the latency.

Purpose: Fulfills requirement WEBU-04 (Test endpoint -- send a prompt from the UI, see which provider served it, response content, and latency). This gives users a quick way to verify their chain configuration works without external tools.

Output: Test page component with prompt input, chain selector, and response display area.
</objective>

<execution_context>
@C:\Users\danen\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\danen\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

@.planning/phases/05-web-ui/05-02-SUMMARY.md

@ui/src/lib/api.ts
@ui/src/lib/queryKeys.ts
@src/api/routes/chat.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create test endpoint page with prompt input and response display</name>
  <files>
    ui/src/pages/Test.tsx
    ui/src/pages/Test.module.css
  </files>
  <action>
Replace the placeholder Test page with a full implementation:

**ui/src/pages/Test.tsx:**

**Input Section:**
- Chain selector: dropdown populated from `useQuery({ queryKey: queryKeys.config, queryFn: api.getConfig })`. Options are chain names from config. Default option: "(default chain)" which sends the request without specifying a model/chain (backend uses defaultChain).
- Prompt text area: multi-line, resizable, placeholder "Enter your message...". Use `useState<string>` for the value.
- "Send" button: triggers the chat completion request. Disabled while request is in flight.
- "Stream" checkbox: toggle between streaming and non-streaming mode. Default: unchecked (non-streaming).

**Request execution:**
- Non-streaming mode: use `useMutation` that calls a function performing:
  1. Record `performance.now()` start time
  2. Call `fetch('/v1/chat/completions', { method: 'POST', headers: { Authorization, Content-Type }, body: JSON.stringify({ model: selectedChain || 'default', messages: [{ role: 'user', content: prompt }], stream: false }) })`
  3. Record end time, compute latency
  4. Parse response JSON
  5. Extract provider from `X-429chain-Provider` response header
  6. Extract attempts from `X-429chain-Attempts` response header
  7. Return `{ response: json, provider: header, attempts: header, latencyMs }`

  IMPORTANT: Do NOT use `api.chatCompletion` from the API client for this because we need access to response headers (X-429chain-Provider, X-429chain-Attempts). Use raw `fetch` directly in the mutation function.

- Streaming mode (if checkbox checked): use raw `fetch` with `stream: true`, read SSE events, display tokens as they arrive. Store accumulated text in state. After stream completes, show final result. Note: streaming mode is a nice-to-have enhancement; implement it if straightforward, otherwise make the checkbox disabled with "(coming soon)" tooltip and only implement non-streaming.

**Response Display Section:**
- Show only after a request completes (or errors)
- **Provider info**: "Served by: {providerId}/{model}" from X-429chain-Provider header
- **Attempts**: "Attempts: {N}" from X-429chain-Attempts header (shows waterfall behavior)
- **Latency**: "Latency: {N}ms" computed client-side
- **Response content**: the assistant's message content (`response.choices[0].message.content`), displayed in a pre-formatted block
- **Token usage**: prompt tokens, completion tokens, total tokens (from `response.usage`)
- **Error display**: if mutation fails, show error message in red. If the response body contains an error object (e.g., all providers exhausted 503), parse and display it.

**State:**
- `prompt: string` - textarea value
- `selectedChain: string` - dropdown value (empty string = use default)
- `streamMode: boolean` - checkbox state
- Mutation state from useMutation: `isPending`, `isError`, `error`, `data`

**ui/src/pages/Test.module.css:**
- Two-panel layout: input (top or left) and response (bottom or right)
- Textarea: full width, min-height 100px, resizable vertically
- Chain selector and controls: row layout above textarea
- Response area: monospace font for content, card-like container
- Provider/latency/tokens info: small text row above response content
- Error: red border and text
- Loading state: pulsing indicator or "Sending..." text on button
  </action>
  <verify>
Run `cd ui && npx tsc --noEmit` -- TypeScript compiles. Run `cd ui && npm run build` -- production build succeeds.
  </verify>
  <done>
Test page has prompt input, chain selector, send button, and response display showing provider, latency, content, and token usage. Error states are handled.
  </done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <what-built>Complete Web UI with all 4 pages: Provider management (CRUD), Chain editor (drag-and-drop reorder), Usage dashboard (stats, request log, live rate limits), and Test endpoint (send prompt, see response with provider/latency info).</what-built>
  <how-to-verify>
1. Start the backend: `npm run dev` (runs on port 3429)
2. In another terminal: `cd ui && npm run dev` (runs Vite on port 5173)
3. Open http://localhost:5173 in browser
4. Verify navigation: click each nav link (Dashboard, Providers, Chains, Test) -- pages should load without full page refresh
5. Set API key: enter a valid API key in the sidebar input and click Set
6. **Dashboard page**: verify stats cards appear (may be empty if no requests yet), request log table renders, rate limit status section shows
7. **Providers page**: verify provider list loads, try adding a new provider (fill form, submit), verify it appears in list, try deleting a provider
8. **Chains page**: verify chain list loads, click a chain to open editor, try dragging entries to reorder, try adding/removing entries
9. **Test page**: type a prompt, select a chain (or default), click Send, verify response shows provider, latency, and content
10. Verify the complete success criteria match: refresh browser on /providers (SPA fallback should work, not 404)

Type "approved" or describe any issues found.
  </how-to-verify>
  <resume-signal>Type "approved" or describe issues</resume-signal>
</task>

</tasks>

<verification>
1. `cd ui && npm run build` succeeds
2. All 4 pages render correctly in browser
3. Test page sends chat completion and displays provider, response, latency
4. SPA fallback works (refresh on /test does not 404)
5. API key from sessionStorage is sent with all requests
</verification>

<success_criteria>
- Test page has prompt textarea, chain selector dropdown, and Send button
- Sending a prompt shows which provider served it (from X-429chain-Provider header)
- Response content is displayed in formatted block
- Latency is shown in milliseconds (client-measured)
- Token usage (prompt, completion, total) is displayed
- Error responses (503 all exhausted, 401 unauthorized) display meaningful messages
- Full Web UI is functional end-to-end across all 4 pages
</success_criteria>

<output>
After completion, create `.planning/phases/05-web-ui/05-06-SUMMARY.md`
</output>
