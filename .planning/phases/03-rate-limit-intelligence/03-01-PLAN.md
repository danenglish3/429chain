---
phase: 03-rate-limit-intelligence
plan: 01
type: tdd
wave: 1
depends_on: []
files_modified:
  - src/ratelimit/types.ts
  - src/ratelimit/tracker.ts
  - src/ratelimit/__tests__/tracker.test.ts
autonomous: true

must_haves:
  truths:
    - "Tracker supports three states: available, tracking, exhausted"
    - "Quota info (remaining requests, remaining tokens, reset times) is stored per provider+model"
    - "Provider transitions to exhausted when remainingRequests reaches 0"
    - "Provider transitions to exhausted when remainingTokens reaches 0"
    - "Tracker uses the longer cooldown when both request and token limits hit zero"
    - "Stale quota data is retained with lastUpdated timestamp"
    - "isExhausted returns true for tracking state entries with zero remaining quota"
  artifacts:
    - path: "src/ratelimit/types.ts"
      provides: "QuotaInfo interface, RateLimitState with 'tracking' state, updated TrackerEntry"
      contains: "tracking"
    - path: "src/ratelimit/tracker.ts"
      provides: "updateQuota method, proactive exhaustion check on quota update"
      exports: ["RateLimitTracker"]
    - path: "src/ratelimit/__tests__/tracker.test.ts"
      provides: "Tests for quota tracking state transitions"
      min_lines: 220
  key_links:
    - from: "src/ratelimit/tracker.ts"
      to: "src/ratelimit/types.ts"
      via: "QuotaInfo import and TrackerEntry.quota field"
      pattern: "quota.*QuotaInfo"
    - from: "src/ratelimit/tracker.ts"
      to: "src/ratelimit/cooldown.ts"
      via: "CooldownManager schedule on proactive exhaustion"
      pattern: "cooldownManager\\.schedule"
---

<objective>
Extend the rate limit tracker state machine from two states (available/exhausted) to three states (available/tracking/exhausted) with quota tracking from parsed rate limit headers.

Purpose: The tracker must store quota data (remaining requests, remaining tokens, reset times) per provider+model so the chain router can proactively skip exhausted providers BEFORE they return 429. This is the foundation for all Phase 3 intelligence.

Output: Extended TrackerEntry with QuotaInfo, updateQuota() method on RateLimitTracker, and proactive exhaustion detection when remaining quota hits zero.
</objective>

<execution_context>
@C:\Users\danen\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\danen\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-rate-limit-intelligence/03-RESEARCH.md

@src/ratelimit/types.ts
@src/ratelimit/tracker.ts
@src/ratelimit/cooldown.ts
@src/ratelimit/__tests__/tracker.test.ts
@src/providers/types.ts
</context>

<feature>
  <name>Three-state rate limit tracker with quota tracking</name>
  <files>
    src/ratelimit/types.ts
    src/ratelimit/tracker.ts
    src/ratelimit/__tests__/tracker.test.ts
  </files>
  <behavior>
    The rate limit state machine adds a 'tracking' state between 'available' and 'exhausted'.

    State transitions:
    - AVAILABLE -> TRACKING: updateQuota() called with RateLimitInfo that has remaining > 0
    - TRACKING -> TRACKING: updateQuota() called again with updated quota values
    - TRACKING -> EXHAUSTED: updateQuota() called with remainingRequests === 0 OR remainingTokens === 0
    - EXHAUSTED -> AVAILABLE: Cooldown timer expires (existing behavior)
    - AVAILABLE -> EXHAUSTED: markExhausted() called directly (existing 429 reactive path, unchanged)

    Type changes to src/ratelimit/types.ts:
    - RateLimitState: add 'tracking' to union -> 'available' | 'tracking' | 'exhausted'
    - Add QuotaInfo interface with fields: remainingRequests?, resetRequestsMs?, remainingTokens?, resetTokensMs?, lastUpdated (number, Date.now())
    - TrackerEntry: add optional quota?: QuotaInfo field

    Method additions to RateLimitTracker:
    - updateQuota(providerId, model, rateLimitInfo: RateLimitInfo): void
      - If remainingRequests === 0 OR remainingTokens === 0: call markExhausted with appropriate cooldown
        - When BOTH are zero, use Math.max of the two reset times as cooldown
        - Reason: 'proactive: remaining requests = 0' or 'proactive: remaining tokens = 0' or 'proactive: remaining requests and tokens = 0'
      - Otherwise: set status to 'tracking', store QuotaInfo with lastUpdated = Date.now()

    Changes to isExhausted():
    - 'tracking' state is NOT exhausted (provider still has quota)
    - Only 'exhausted' state returns true (same as before, but now 'tracking' is explicitly not exhausted)

    Changes to getStatus() and getAllStatuses():
    - CooldownEntry should include optional quota field for observability
    - Update CooldownEntry interface to include quota?: QuotaInfo

    Test cases (RED phase - write these FIRST):
    1. updateQuota with remaining > 0 transitions to 'tracking'
    2. updateQuota with remainingRequests === 0 transitions to 'exhausted'
    3. updateQuota with remainingTokens === 0 transitions to 'exhausted'
    4. updateQuota with BOTH remaining === 0 uses Math.max of reset times
    5. isExhausted returns false for 'tracking' state
    6. updateQuota updates existing 'tracking' entry with new quota values
    7. getStatus includes quota info for 'tracking' entries
    8. After exhaustion from quota, auto-recovery timer fires and marks available
    9. updateQuota stores lastUpdated timestamp
    10. All existing tests still pass (no regression)
  </behavior>
  <implementation>
    RED: Write all 10 test cases in tracker.test.ts in a new describe block 'Quota Tracking'.
    Import RateLimitInfo from providers/types.ts for test data.
    Run tests -- all new tests should FAIL (updateQuota doesn't exist yet).

    GREEN:
    1. Update src/ratelimit/types.ts:
       - Add 'tracking' to RateLimitState union
       - Add QuotaInfo interface
       - Add quota?: QuotaInfo to TrackerEntry
       - Add quota?: QuotaInfo to CooldownEntry

    2. Update src/ratelimit/tracker.ts:
       - Import RateLimitInfo from '../providers/types.js'
       - Add updateQuota(providerId, model, info: RateLimitInfo) method:
         - Check remainingRequests === 0 OR remainingTokens === 0
         - If either is zero: compute cooldown from resetMs values, call markExhausted with reason
         - If neither is zero: set entry to { status: 'tracking', cooldownUntil: null, reason: 'tracking quota', quota: { ... } }
       - Update isExhausted to handle 'tracking' state (return false, same as 'available')
       - Update getStatus/getAllStatuses to include quota in CooldownEntry

    Run tests -- all should PASS including existing tests.

    REFACTOR: Clean up if needed. Ensure no duplication between updateQuota exhaustion logic and existing markExhausted.
  </implementation>
</feature>

<verification>
- `npx tsc --noEmit` passes with zero errors
- `npx vitest run src/ratelimit` passes all existing + new tests
- RateLimitState type includes 'tracking'
- TrackerEntry has optional quota field
- updateQuota method exists on RateLimitTracker
</verification>

<success_criteria>
- All existing tracker tests pass (no regression)
- 10+ new quota tracking tests pass
- 'tracking' state properly distinguishes from 'available' and 'exhausted'
- Proactive exhaustion triggers on remainingRequests === 0 or remainingTokens === 0
- Cooldown uses Math.max when both limits are zero
- QuotaInfo includes lastUpdated timestamp
</success_criteria>

<output>
After completion, create `.planning/phases/03-rate-limit-intelligence/03-01-SUMMARY.md`
</output>
