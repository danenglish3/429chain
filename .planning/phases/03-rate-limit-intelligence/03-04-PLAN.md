---
phase: 03-rate-limit-intelligence
plan: 04
type: execute
wave: 1
depends_on: []
files_modified: [src/index.ts]
autonomous: true
gap_closure: true

must_haves:
  truths:
    - "When a provider has rateLimits configured in YAML, tracker.hasManualLimits() returns true for that provider+model pair at runtime"
    - "Manual rate limit enforcement activates on requests to providers with configured rateLimits but no response headers"
  artifacts:
    - path: "src/index.ts"
      provides: "Manual rate limit initialization loop after tracker creation"
      contains: "registerManualLimits"
  key_links:
    - from: "src/index.ts"
      to: "tracker.registerManualLimits()"
      via: "initialization loop iterating config.providers and chains"
      pattern: "tracker\\.registerManualLimits"
    - from: "config.providers[].rateLimits"
      to: "tracker.manualLimits Map"
      via: "registerManualLimits called for each provider+model pair"
      pattern: "provider\\.rateLimits"
---

<objective>
Wire manual rate limit configuration into application startup so that providers with rateLimits in config have their limits registered in the tracker before any requests are handled.

Purpose: Closes the critical gap where manual rate limit infrastructure exists but is never initialized -- config.providers[].rateLimits is silently ignored because src/index.ts never calls tracker.registerManualLimits(). This blocks RATE-05 (manual rate limit configuration per provider as fallback).

Output: Updated src/index.ts with initialization loop that registers manual limits from config.
</objective>

<execution_context>
@C:\Users\danen\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\danen\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-rate-limit-intelligence/03-VERIFICATION.md

@src/index.ts
@src/ratelimit/tracker.ts
@src/config/schema.ts
@src/chain/types.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add manual rate limit initialization loop to src/index.ts</name>
  <files>src/index.ts</files>
  <action>
After the tracker is created on line 32 (`const tracker = new RateLimitTracker(config.settings.cooldownDefaultMs);`), add a manual rate limit registration block.

The logic:

1. Iterate through `config.providers`
2. For each provider that has `rateLimits` defined (it is optional), collect all models that reference this provider across ALL chains
3. For each unique model, call `tracker.registerManualLimits(provider.id, model, provider.rateLimits)`
4. Log how many manual limit registrations were made (info level)

Implementation details:

```typescript
// --- Register manual rate limits from config ---

let manualLimitCount = 0;
for (const provider of config.providers) {
  if (!provider.rateLimits) continue;

  // Collect all models used with this provider across all chains
  const models = new Set<string>();
  for (const chainConfig of config.chains) {
    for (const entry of chainConfig.entries) {
      if (entry.provider === provider.id) {
        models.add(entry.model);
      }
    }
  }

  // Register manual limits for each provider+model pair
  for (const model of models) {
    tracker.registerManualLimits(provider.id, model, provider.rateLimits);
    manualLimitCount++;
  }
}

if (manualLimitCount > 0) {
  logger.info({ count: manualLimitCount }, `Registered ${manualLimitCount} manual rate limit(s)`);
}
```

Place this block BETWEEN the tracker creation (line 32) and the "Create Hono application" section (line 34). Add a blank line before and after for visual separation.

Do NOT change any other code in the file. Do NOT add new imports (logger and config are already available).
  </action>
  <verify>
1. Run `npx tsc --noEmit` -- should pass with no errors
2. Run `npx vitest run` -- all 82+ tests should pass (no regressions)
3. Grep src/index.ts for `registerManualLimits` -- should find the call
4. Grep src/index.ts for `provider.rateLimits` -- should find the guard check
  </verify>
  <done>
src/index.ts contains initialization loop that reads config.providers[].rateLimits and calls tracker.registerManualLimits() for each provider+model pair found in chains. TypeScript compiles cleanly and all existing tests pass.
  </done>
</task>

<task type="auto">
  <name>Task 2: Verify end-to-end wiring with integration test</name>
  <files>src/ratelimit/__tests__/tracker.test.ts</files>
  <action>
Add a focused test that simulates the exact initialization pattern used in src/index.ts to confirm the wiring works end-to-end. This test proves that the startup loop pattern correctly makes hasManualLimits() return true and recordRequest() enforce limits.

Add a new describe block at the end of the existing test file:

```typescript
describe('startup initialization pattern', () => {
  it('registers manual limits for provider+model pairs found in chains', () => {
    const tracker = new RateLimitTracker(60000);

    // Simulate config.providers with rateLimits
    const providers = [
      { id: 'groq', rateLimits: { requestsPerMinute: 30 } },
      { id: 'openrouter' }, // No rateLimits
    ];

    // Simulate config.chains
    const chains = [
      {
        entries: [
          { provider: 'groq', model: 'llama-3.3-70b' },
          { provider: 'openrouter', model: 'gpt-4o' },
        ],
      },
      {
        entries: [
          { provider: 'groq', model: 'gemma2-9b' },
        ],
      },
    ];

    // Replicate the initialization loop from index.ts
    for (const provider of providers) {
      if (!('rateLimits' in provider) || !provider.rateLimits) continue;

      const models = new Set<string>();
      for (const chain of chains) {
        for (const entry of chain.entries) {
          if (entry.provider === provider.id) {
            models.add(entry.model);
          }
        }
      }

      for (const model of models) {
        tracker.registerManualLimits(provider.id, model, provider.rateLimits);
      }
    }

    // Verify: groq models have manual limits
    expect(tracker.hasManualLimits('groq', 'llama-3.3-70b')).toBe(true);
    expect(tracker.hasManualLimits('groq', 'gemma2-9b')).toBe(true);

    // Verify: openrouter does NOT have manual limits (no rateLimits in config)
    expect(tracker.hasManualLimits('openrouter', 'gpt-4o')).toBe(false);

    // Verify: groq model NOT in any chain is not registered
    expect(tracker.hasManualLimits('groq', 'nonexistent-model')).toBe(false);
  });
});
```

Do NOT modify any existing tests. Only add this new describe block at the end of the file.
  </action>
  <verify>
1. Run `npx vitest run src/ratelimit/__tests__/tracker.test.ts` -- new test passes
2. Run `npx vitest run` -- all tests pass (no regressions), total count should be 83+
  </verify>
  <done>
Integration test confirms that the startup initialization pattern correctly registers manual limits only for provider+model pairs that have rateLimits configured AND appear in chains. Test passes alongside all existing tests with no regressions.
  </done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit` -- zero errors
2. `npx vitest run` -- all tests pass (83+ total, no regressions)
3. `grep -n "registerManualLimits" src/index.ts` -- shows the initialization call
4. The verification gap from 03-VERIFICATION.md is closed: src/index.ts now reads config.providers[].rateLimits and calls tracker.registerManualLimits()
</verification>

<success_criteria>
- src/index.ts initializes manual rate limits from config during startup
- tracker.hasManualLimits() returns true for providers with configured rateLimits
- The router's else-branch (manual fallback) is now reachable at runtime
- All existing tests pass with no regressions
- New integration test validates the initialization pattern
- RATE-05 (manual rate limit configuration) is unblocked
</success_criteria>

<output>
After completion, create `.planning/phases/03-rate-limit-intelligence/03-04-SUMMARY.md`
</output>
