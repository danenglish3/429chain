---
phase: 03-rate-limit-intelligence
plan: 03
type: execute
wave: 3
depends_on: ["03-01", "03-02"]
files_modified:
  - src/config/schema.ts
  - src/config/types.ts
  - config/config.example.yaml
  - src/ratelimit/tracker.ts
  - src/ratelimit/__tests__/tracker.test.ts
  - src/chain/router.ts
  - src/chain/__tests__/router.test.ts
autonomous: true

must_haves:
  truths:
    - "Users can configure rateLimits (requestsPerMinute, tokensPerMinute, requestsPerDay) per provider in config YAML"
    - "Manual rate limits act as fallback: only enforced when no headers are available from the provider"
    - "When manual requestsPerMinute is configured and no headers exist, tracker enforces the RPM limit"
    - "Manual config is validated by Zod schema with proper types and constraints"
    - "Existing configs without rateLimits field continue to work (field is optional)"
    - "Chain router invokes recordRequest when headers are absent but manual limits exist"
  artifacts:
    - path: "src/config/schema.ts"
      provides: "RateLimitConfigSchema and rateLimits field on ProviderSchema"
      contains: "rateLimits"
    - path: "src/config/types.ts"
      provides: "RateLimitConfig type inferred from schema"
      contains: "RateLimitConfig"
    - path: "config/config.example.yaml"
      provides: "Example rateLimits configuration with comments"
      contains: "rateLimits"
    - path: "src/ratelimit/tracker.ts"
      provides: "Manual limit registration, fallback enforcement, and hasManualLimits check"
      exports: ["RateLimitTracker"]
    - path: "src/ratelimit/__tests__/tracker.test.ts"
      provides: "Tests for manual rate limit fallback behavior"
      min_lines: 250
    - path: "src/chain/router.ts"
      provides: "Manual fallback else-branch in executeChain and executeStreamChain"
      exports: ["executeChain", "executeStreamChain"]
    - path: "src/chain/__tests__/router.test.ts"
      provides: "Tests for manual fallback wiring in both chain paths"
      min_lines: 320
  key_links:
    - from: "src/config/schema.ts"
      to: "src/config/types.ts"
      via: "z.infer type derivation"
      pattern: "z\\.infer.*RateLimitConfig"
    - from: "src/ratelimit/tracker.ts"
      to: "manual limit check in recordRequest"
      via: "fallback enforcement when no headers present"
      pattern: "manualLimits"
    - from: "src/chain/router.ts"
      to: "src/ratelimit/tracker.ts"
      via: "else-branch calling tracker.recordRequest when parseRateLimitHeaders returns null and hasManualLimits is true"
      pattern: "tracker\\.recordRequest"
---

<objective>
Add manual rate limit configuration per provider in the config schema, implement fallback enforcement in the tracker, and wire the manual fallback into the chain router so it is actually invoked when headers are absent.

Purpose: Not all providers send rate limit headers. Users need a fallback mechanism to configure known limits (e.g., "Groq allows 30 requests per minute on free tier") so the proxy can still track quota proactively. The router must invoke this fallback -- without router wiring, the manual limits exist but are never enforced. This satisfies requirement RATE-05.

Output: RateLimitConfigSchema in config, rateLimits field on providers in YAML, manual limit enforcement in the tracker, and router wiring that calls recordRequest() when no headers are available but manual limits are registered.
</objective>

<execution_context>
@C:\Users\danen\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\danen\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-rate-limit-intelligence/03-RESEARCH.md
@.planning/phases/03-rate-limit-intelligence/03-01-SUMMARY.md
@.planning/phases/03-rate-limit-intelligence/03-02-SUMMARY.md

@src/config/schema.ts
@src/config/types.ts
@config/config.example.yaml
@src/ratelimit/tracker.ts
@src/ratelimit/types.ts
@src/ratelimit/__tests__/tracker.test.ts
@src/chain/router.ts
@src/chain/__tests__/router.test.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add RateLimitConfigSchema to provider config and update example YAML</name>
  <files>
    src/config/schema.ts
    src/config/types.ts
    config/config.example.yaml
  </files>
  <action>
    1. In src/config/schema.ts, add a new RateLimitConfigSchema BEFORE ProviderSchema:
    ```typescript
    /** Schema for optional per-provider rate limit configuration (fallback when headers unavailable). */
    export const RateLimitConfigSchema = z.object({
      requestsPerMinute: z.number().int().positive().optional(),
      tokensPerMinute: z.number().int().positive().optional(),
      requestsPerDay: z.number().int().positive().optional(),
      concurrentRequests: z.number().int().positive().optional(),
    });
    ```

    2. Add `rateLimits` field to ProviderSchema as optional:
    ```typescript
    export const ProviderSchema = z.object({
      id: z.string().min(1, { message: 'Provider id must not be empty' }),
      name: z.string().min(1, { message: 'Provider name must not be empty' }),
      type: z.enum(['openrouter', 'groq', 'cerebras', 'generic-openai']),
      apiKey: z.string().min(1, { message: 'Provider apiKey must not be empty' }),
      baseUrl: z.url({ message: 'Provider baseUrl must be a valid URL' }).optional(),
      rateLimits: RateLimitConfigSchema.optional(),
    });
    ```

    3. In src/config/types.ts, add the RateLimitConfig type:
    ```typescript
    import { RateLimitConfigSchema } from './schema.js';
    // ... existing imports

    /** Per-provider rate limit configuration (manual fallback). */
    export type RateLimitConfig = z.infer<typeof RateLimitConfigSchema>;
    ```
    Also add RateLimitConfigSchema to the re-export block.

    4. In config/config.example.yaml, add rateLimits examples to the groq provider (which has known free tier limits) with explanatory comments:
    ```yaml
      - id: groq
        name: Groq
        type: groq
        apiKey: "gsk_your-key-here"
        # Optional: manual rate limits as fallback when provider headers unavailable
        rateLimits:
          requestsPerMinute: 30    # Groq free tier: 30 RPM
          tokensPerMinute: 15000   # Groq free tier: ~15k TPM
          # requestsPerDay: 14400  # Optional daily limit
          # concurrentRequests: 1  # Optional concurrent limit (enforcement deferred)
    ```
    Do NOT add rateLimits to the other providers (show it as optional by example).

    Ensure existing configs without rateLimits still validate (field is optional, so this is automatic with Zod).
  </action>
  <verify>
    `npx tsc --noEmit` passes with zero errors.
    `npx vitest run src/config` passes all existing config tests.
    The RateLimitConfig type is exported from src/config/types.ts.
  </verify>
  <done>
    rateLimits field is available on provider config (optional).
    RateLimitConfigSchema validates integer positive numbers.
    config.example.yaml shows usage on one provider.
    Existing configs without rateLimits still validate.
  </done>
</task>

<task type="auto">
  <name>Task 2: Implement registerManualLimits and ManualLimitState storage in tracker</name>
  <files>
    src/ratelimit/tracker.ts
    src/ratelimit/__tests__/tracker.test.ts
  </files>
  <action>
    Add manual rate limit registration to RateLimitTracker. This task focuses on storing manual limits and exposing them via hasManualLimits(). The enforcement logic (recordRequest) is Task 3.

    1. Add a new Map to store manual limits per provider+model:
    ```typescript
    private manualLimits = new Map<string, ManualLimitState>();
    ```

    Define ManualLimitState interface in tracker.ts (private/internal):
    ```typescript
    interface ManualLimitState {
      requestsPerMinute?: number;
      tokensPerMinute?: number;
      requestsPerDay?: number;
      // Tracking counters
      requestCount: number;
      tokenCount: number;
      windowStart: number; // Date.now() when current minute window started
      dailyRequestCount: number;
      dailyWindowStart: number; // Date.now() when current day window started
    }
    ```

    2. Add registerManualLimits(providerId: string, model: string, limits: { requestsPerMinute?: number; tokensPerMinute?: number; requestsPerDay?: number }) method:
    - Stores the manual limits for a provider+model pair using the same composite key pattern
    - Initializes counters to 0, windowStart and dailyWindowStart to Date.now()
    - This is called during app initialization when config is loaded

    3. Add hasManualLimits(providerId: string, model: string): boolean method:
    - Returns true if manual limits are registered for this provider+model pair
    - Used by the chain router to determine whether to call recordRequest()

    Tests (add to tracker.test.ts in new describe block 'Manual Rate Limits - Registration'):
    1. registerManualLimits stores limits for a provider+model
    2. hasManualLimits returns true for registered pairs
    3. hasManualLimits returns false for unregistered pairs
    4. registerManualLimits can update existing limits (re-register)
  </action>
  <verify>
    `npx tsc --noEmit` passes with zero errors.
    `npx vitest run src/ratelimit` passes all existing + new tests.
  </verify>
  <done>
    registerManualLimits() stores manual limits per provider+model.
    hasManualLimits() returns boolean for router to check.
    ManualLimitState interface defined with counter fields.
    4 new tests for registration behavior.
  </done>
</task>

<task type="auto">
  <name>Task 3: Implement recordRequest enforcement with window-based counters</name>
  <files>
    src/ratelimit/tracker.ts
    src/ratelimit/__tests__/tracker.test.ts
  </files>
  <action>
    Add recordRequest() to RateLimitTracker. This method enforces manual rate limits by tracking request/token counts within time windows.

    1. Add recordRequest(providerId: string, model: string, tokensUsed?: number) method:
    - Looks up ManualLimitState for this provider+model (return early if none registered)
    - Checks if minute window has elapsed (Date.now() - windowStart > 60000); if so, reset requestCount, tokenCount, and set windowStart to Date.now()
    - Checks if daily window has elapsed (Date.now() - dailyWindowStart > 86400000); if so, reset dailyRequestCount and set dailyWindowStart to Date.now()
    - Increments requestCount by 1
    - If tokensUsed provided, increments tokenCount by tokensUsed
    - Increments dailyRequestCount by 1
    - After incrementing, check if any manual limit is exceeded:
      - requestCount >= requestsPerMinute -> markExhausted with cooldown = remaining ms in minute window (60000 - (Date.now() - windowStart)), reason: 'manual limit: RPM exceeded'
      - tokenCount >= tokensPerMinute -> markExhausted with cooldown = remaining ms in minute window, reason: 'manual limit: TPM exceeded'
      - dailyRequestCount >= requestsPerDay -> markExhausted with cooldown = remaining ms in day window (86400000 - (Date.now() - dailyWindowStart)), reason: 'manual limit: daily request limit exceeded'

    This method is only called by the router when parseRateLimitHeaders returns null (fallback).

    Tests (add to tracker.test.ts in new describe block 'Manual Rate Limits - Enforcement'):
    1. recordRequest increments count and does NOT exhaust when under limit
    2. recordRequest exhausts when requestsPerMinute is reached
    3. recordRequest exhausts when tokensPerMinute is reached
    4. recordRequest resets counters when minute window elapses (use vi.useFakeTimers())
    5. recordRequest exhausts when requestsPerDay is reached
    6. recordRequest resets daily counters when day window elapses (use vi.useFakeTimers())
    7. Manual limits do not interfere with header-based tracking (updateQuota still works independently)
    8. recordRequest is a no-op for providers without manual limits registered
  </action>
  <verify>
    `npx tsc --noEmit` passes with zero errors.
    `npx vitest run src/ratelimit` passes all existing + new tests.
  </verify>
  <done>
    recordRequest() enforces RPM, TPM, and daily request limits as fallback.
    Minute and day windows reset automatically.
    8 new tests for enforcement behavior.
    Zero test regressions.
  </done>
</task>

<task type="auto">
  <name>Task 4: Wire manual rate limit fallback into chain router</name>
  <files>
    src/chain/router.ts
    src/chain/__tests__/router.test.ts
  </files>
  <action>
    Wire the manual fallback into both executeChain and executeStreamChain. After Plan 03-02, both functions already have the pattern:
    ```typescript
    const rateLimitInfo = adapter.parseRateLimitHeaders(result.headers);
    if (rateLimitInfo) {
      tracker.updateQuota(entry.providerId, entry.model, rateLimitInfo);
    }
    ```

    Add an else-branch to call recordRequest when no headers are available but manual limits exist.

    1. In executeChain (non-streaming), after the existing `if (rateLimitInfo)` block that calls updateQuota, add:
    ```typescript
    if (rateLimitInfo) {
      tracker.updateQuota(entry.providerId, entry.model, rateLimitInfo);
    } else if (tracker.hasManualLimits(entry.providerId, entry.model)) {
      // No headers from provider -- fall back to manual limit tracking
      tracker.recordRequest(entry.providerId, entry.model);
    }
    ```

    2. In executeStreamChain (streaming), add the same else-branch pattern after the existing `if (rateLimitInfo)` block:
    ```typescript
    if (rateLimitInfo) {
      tracker.updateQuota(entry.providerId, entry.model, rateLimitInfo);
    } else if (tracker.hasManualLimits(entry.providerId, entry.model)) {
      tracker.recordRequest(entry.providerId, entry.model);
    }
    ```

    3. Add tests to router.test.ts in a new describe block 'Manual rate limit fallback':
    a. Test: when parseRateLimitHeaders returns null AND manual limits registered, recordRequest is called (spy on tracker.recordRequest)
    b. Test: when parseRateLimitHeaders returns null AND NO manual limits, recordRequest is NOT called
    c. Test: when parseRateLimitHeaders returns info, recordRequest is NOT called (header path takes precedence)
    d. Test: streaming path calls recordRequest when no headers but manual limits exist
    e. Test: after enough requests to exceed manual RPM limit, provider is exhausted on next chain execution

    For these tests, use vi.spyOn on tracker methods. Create mock adapters where parseRateLimitHeaders returns null. Pre-register manual limits via tracker.registerManualLimits().
  </action>
  <verify>
    `npx tsc --noEmit` passes with zero errors.
    `npx vitest run src/chain` passes all existing + new tests.
    `npx vitest run` (full suite) passes.
  </verify>
  <done>
    Both executeChain and executeStreamChain invoke tracker.recordRequest() when no rate limit headers are present and manual limits are registered.
    Headers take precedence over manual limits (if/else, not both).
    5+ new tests covering manual fallback wiring in both paths.
    Zero test regressions.
  </done>
</task>

</tasks>

<verification>
- `npx tsc --noEmit` passes
- `npx vitest run` passes full test suite
- Provider config accepts optional rateLimits field
- Existing configs without rateLimits still validate
- Manual limits are enforced as fallback (only when no headers)
- Chain router actually invokes recordRequest when headers absent
- config.example.yaml documents the rateLimits usage
</verification>

<success_criteria>
- RateLimitConfigSchema validates manual rate limit config
- ProviderSchema includes optional rateLimits field
- RateLimitConfig type is exported from config/types.ts
- config.example.yaml shows rateLimits on one provider with comments
- registerManualLimits() and recordRequest() methods work on tracker
- hasManualLimits() returns correct boolean for router integration
- Manual limits enforce RPM, TPM, and daily request limits
- Window-based counters reset correctly
- Chain router calls recordRequest() when no headers but manual limits exist
- Headers take precedence over manual limits (if/else branch)
- 17+ new tests across tracker and router
- All existing tests pass (no regression)
</success_criteria>

<output>
After completion, create `.planning/phases/03-rate-limit-intelligence/03-03-SUMMARY.md`
</output>
