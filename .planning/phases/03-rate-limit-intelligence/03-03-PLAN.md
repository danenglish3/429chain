---
phase: 03-rate-limit-intelligence
plan: 03
type: execute
wave: 2
depends_on: ["03-01"]
files_modified:
  - src/config/schema.ts
  - src/config/types.ts
  - config/config.example.yaml
  - src/ratelimit/tracker.ts
  - src/ratelimit/__tests__/tracker.test.ts
autonomous: true

must_haves:
  truths:
    - "Users can configure rateLimits (requestsPerMinute, tokensPerMinute, requestsPerDay) per provider in config YAML"
    - "Manual rate limits act as fallback: only enforced when no headers are available from the provider"
    - "When manual requestsPerMinute is configured and no headers exist, tracker enforces the RPM limit"
    - "Manual config is validated by Zod schema with proper types and constraints"
    - "Existing configs without rateLimits field continue to work (field is optional)"
  artifacts:
    - path: "src/config/schema.ts"
      provides: "RateLimitConfigSchema and rateLimits field on ProviderSchema"
      contains: "rateLimits"
    - path: "src/config/types.ts"
      provides: "RateLimitConfig type inferred from schema"
      contains: "RateLimitConfig"
    - path: "config/config.example.yaml"
      provides: "Example rateLimits configuration with comments"
      contains: "rateLimits"
    - path: "src/ratelimit/tracker.ts"
      provides: "Manual limit registration and fallback enforcement in updateQuota"
      exports: ["RateLimitTracker"]
    - path: "src/ratelimit/__tests__/tracker.test.ts"
      provides: "Tests for manual rate limit fallback behavior"
      min_lines: 250
  key_links:
    - from: "src/config/schema.ts"
      to: "src/config/types.ts"
      via: "z.infer type derivation"
      pattern: "z\\.infer.*RateLimitConfig"
    - from: "src/ratelimit/tracker.ts"
      to: "manual limit check in updateQuota"
      via: "fallback enforcement when no headers present"
      pattern: "manualLimits"
---

<objective>
Add manual rate limit configuration per provider in the config schema and implement fallback enforcement in the tracker when providers do not send rate limit headers.

Purpose: Not all providers send rate limit headers. Users need a fallback mechanism to configure known limits (e.g., "Groq allows 30 requests per minute on free tier") so the proxy can still track quota proactively. This satisfies requirement RATE-05.

Output: RateLimitConfigSchema in config, rateLimits field on providers in YAML, and manual limit enforcement in the tracker as fallback when no headers are available.
</objective>

<execution_context>
@C:\Users\danen\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\danen\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-rate-limit-intelligence/03-RESEARCH.md
@.planning/phases/03-rate-limit-intelligence/03-01-SUMMARY.md

@src/config/schema.ts
@src/config/types.ts
@config/config.example.yaml
@src/ratelimit/tracker.ts
@src/ratelimit/types.ts
@src/ratelimit/__tests__/tracker.test.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add RateLimitConfigSchema to provider config and update example YAML</name>
  <files>
    src/config/schema.ts
    src/config/types.ts
    config/config.example.yaml
  </files>
  <action>
    1. In src/config/schema.ts, add a new RateLimitConfigSchema BEFORE ProviderSchema:
    ```typescript
    /** Schema for optional per-provider rate limit configuration (fallback when headers unavailable). */
    export const RateLimitConfigSchema = z.object({
      requestsPerMinute: z.number().int().positive().optional(),
      tokensPerMinute: z.number().int().positive().optional(),
      requestsPerDay: z.number().int().positive().optional(),
      concurrentRequests: z.number().int().positive().optional(),
    });
    ```

    2. Add `rateLimits` field to ProviderSchema as optional:
    ```typescript
    export const ProviderSchema = z.object({
      id: z.string().min(1, { message: 'Provider id must not be empty' }),
      name: z.string().min(1, { message: 'Provider name must not be empty' }),
      type: z.enum(['openrouter', 'groq', 'cerebras', 'generic-openai']),
      apiKey: z.string().min(1, { message: 'Provider apiKey must not be empty' }),
      baseUrl: z.url({ message: 'Provider baseUrl must be a valid URL' }).optional(),
      rateLimits: RateLimitConfigSchema.optional(),
    });
    ```

    3. In src/config/types.ts, add the RateLimitConfig type:
    ```typescript
    import { RateLimitConfigSchema } from './schema.js';
    // ... existing imports

    /** Per-provider rate limit configuration (manual fallback). */
    export type RateLimitConfig = z.infer<typeof RateLimitConfigSchema>;
    ```
    Also add RateLimitConfigSchema to the re-export block.

    4. In config/config.example.yaml, add rateLimits examples to the groq provider (which has known free tier limits) with explanatory comments:
    ```yaml
      - id: groq
        name: Groq
        type: groq
        apiKey: "gsk_your-key-here"
        # Optional: manual rate limits as fallback when provider headers unavailable
        rateLimits:
          requestsPerMinute: 30    # Groq free tier: 30 RPM
          tokensPerMinute: 15000   # Groq free tier: ~15k TPM
          # requestsPerDay: 14400  # Optional daily limit
          # concurrentRequests: 1  # Optional concurrent limit (enforcement deferred)
    ```
    Do NOT add rateLimits to the other providers (show it as optional by example).

    Ensure existing configs without rateLimits still validate (field is optional, so this is automatic with Zod).
  </action>
  <verify>
    `npx tsc --noEmit` passes with zero errors.
    `npx vitest run src/config` passes all existing config tests.
    The RateLimitConfig type is exported from src/config/types.ts.
  </verify>
  <done>
    rateLimits field is available on provider config (optional).
    RateLimitConfigSchema validates integer positive numbers.
    config.example.yaml shows usage on one provider.
    Existing configs without rateLimits still validate.
  </done>
</task>

<task type="auto">
  <name>Task 2: Implement manual rate limit fallback enforcement in tracker</name>
  <files>
    src/ratelimit/tracker.ts
    src/ratelimit/__tests__/tracker.test.ts
  </files>
  <action>
    Add manual rate limit registration and fallback enforcement to RateLimitTracker.

    1. Add a new Map to store manual limits per provider+model:
    ```typescript
    private manualLimits = new Map<string, ManualLimitState>();
    ```

    Define ManualLimitState interface (can be in types.ts or inline in tracker.ts -- keep it in tracker.ts as private since it's internal):
    ```typescript
    interface ManualLimitState {
      requestsPerMinute?: number;
      tokensPerMinute?: number;
      requestsPerDay?: number;
      // Tracking counters
      requestCount: number;
      tokenCount: number;
      windowStart: number; // Date.now() when current minute window started
      dailyRequestCount: number;
      dailyWindowStart: number; // Date.now() when current day window started
    }
    ```

    2. Add registerManualLimits(providerId: string, model: string, limits: { requestsPerMinute?: number; tokensPerMinute?: number; requestsPerDay?: number }) method:
    - Stores the manual limits for a provider+model pair
    - Initializes counters to 0 and windowStart to Date.now()
    - This is called during app initialization when config is loaded

    3. Add recordRequest(providerId: string, model: string, tokensUsed?: number) method:
    - Increments request count and token count for manual limit tracking
    - Checks if minute window has elapsed (Date.now() - windowStart > 60000); if so, reset counters
    - Checks if daily window has elapsed (Date.now() - dailyWindowStart > 86400000); if so, reset daily counters
    - After incrementing, check if any manual limit is exceeded:
      - requestCount >= requestsPerMinute -> markExhausted with cooldown = remaining ms in minute window
      - tokenCount >= tokensPerMinute -> markExhausted with cooldown = remaining ms in minute window
      - dailyRequestCount >= requestsPerDay -> markExhausted with cooldown = remaining ms in day window
    - This method is only called when the provider does NOT send rate limit headers (fallback)

    4. Modify updateQuota to accept an optional `manualFallback` parameter or check internally:
    - If RateLimitInfo is provided (from headers): use header-based tracking as-is (existing behavior from Plan 01)
    - If RateLimitInfo is null AND manual limits exist: call recordRequest instead
    - This keeps the "manual = fallback" semantics clear

    Actually, simpler approach: Do NOT modify updateQuota. Instead, the chain router will:
    - If parseRateLimitHeaders returns info: call tracker.updateQuota()
    - If parseRateLimitHeaders returns null AND manual limits registered: call tracker.recordRequest()

    The router integration is Plan 02's concern. This task just adds registerManualLimits() and recordRequest() to the tracker. BUT Plan 02 handles router changes. So we need a way for Plan 02's router to know about manual limits.

    Since Plan 02 and Plan 03 are parallel (Wave 2), the router changes for manual fallback need to be in THIS plan. Add a small method to tracker: hasManualLimits(providerId, model): boolean.

    Then in the VERIFICATION section, note that the router wiring for manual limits will be a small addition after Plan 02 completes (or can be handled in verification/gap closure). For now, the tracker has the full API and tests.

    Tests (add to tracker.test.ts in new describe block 'Manual Rate Limits'):
    1. registerManualLimits stores limits for a provider+model
    2. recordRequest increments count and does NOT exhaust when under limit
    3. recordRequest exhausts when requestsPerMinute is reached
    4. recordRequest exhausts when tokensPerMinute is reached
    5. recordRequest resets counters when minute window elapses
    6. recordRequest exhausts when requestsPerDay is reached
    7. hasManualLimits returns true for registered pairs, false for others
    8. Manual limits do not interfere with header-based tracking (updateQuota still works independently)

    Use vi.useFakeTimers() for window reset tests to avoid flaky timing.
  </action>
  <verify>
    `npx tsc --noEmit` passes with zero errors.
    `npx vitest run src/ratelimit` passes all existing + new tests.
    `npx vitest run` (full suite) passes.
  </verify>
  <done>
    registerManualLimits() and recordRequest() methods exist on RateLimitTracker.
    Manual limits enforce RPM, TPM, and daily request limits as fallback.
    Minute and day windows reset automatically.
    hasManualLimits() allows router to check if fallback should be used.
    8+ new tests for manual rate limit behavior.
    Zero test regressions.
  </done>
</task>

</tasks>

<verification>
- `npx tsc --noEmit` passes
- `npx vitest run` passes full test suite
- Provider config accepts optional rateLimits field
- Existing configs without rateLimits still validate
- Manual limits are enforced as fallback (only when no headers)
- config.example.yaml documents the rateLimits usage
</verification>

<success_criteria>
- RateLimitConfigSchema validates manual rate limit config
- ProviderSchema includes optional rateLimits field
- RateLimitConfig type is exported from config/types.ts
- config.example.yaml shows rateLimits on one provider with comments
- registerManualLimits() and recordRequest() methods work on tracker
- Manual limits enforce RPM, TPM, and daily request limits
- Window-based counters reset correctly
- 8+ new manual limit tests pass
- All existing tests pass (no regression)
</success_criteria>

<output>
After completion, create `.planning/phases/03-rate-limit-intelligence/03-03-SUMMARY.md`
</output>
